<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>进化</title>
  
  <subtitle>刘少卿的个人网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tonnyone.github.io/"/>
  <updated>2021-01-11T21:33:44.474Z</updated>
  <id>http://tonnyone.github.io/</id>
  
  <author>
    <name>刘少卿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kafka 学习系列 04-spring boot 集成 spring-kafka</title>
    <link href="http://tonnyone.github.io/2018/06/12/kafka/kafka4/"/>
    <id>http://tonnyone.github.io/2018/06/12/kafka/kafka4/</id>
    <published>2018-06-12T02:10:00.000Z</published>
    <updated>2021-01-11T21:33:44.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring和kafka的集成的三种方式"><a href="#spring和kafka的集成的三种方式" class="headerlink" title="spring和kafka的集成的三种方式"></a>spring和kafka的集成的三种方式</h2><ul><li>spring-kafka</li><li>spring-integration for kafka</li><li>spring cloud stream kafka</li></ul><p>以上每一种都在上一种的基础上进行封装集成。spring integretion 2.0以前版本并不基于spring for kafka</p><table><thead><tr><th style="text-align:left">spring for kafka</th><th style="text-align:left">spring integration for kafka</th><th>kafka-clients</th></tr></thead><tbody><tr><td style="text-align:left">2.2.*</td><td style="text-align:left">3.1.*</td><td>1.1.*</td></tr><tr><td style="text-align:left">2.1.*</td><td style="text-align:left">3.0.*</td><td>1.0.*,1.1.*</td></tr><tr><td style="text-align:left">2.0.*</td><td style="text-align:left">3.0.*</td><td>0.11.0.*,1.0.*</td></tr><tr><td style="text-align:left">1.3.*</td><td style="text-align:left">2.3.*</td><td>0.11.0.*,1.0.*</td></tr><tr><td style="text-align:left">1.2.*</td><td style="text-align:left">2.2.*</td><td>0.10.2.*</td></tr><tr><td style="text-align:left">1.1.*</td><td style="text-align:left">2.1.*</td><td>0.10.0.*,0.10.1.*</td></tr><tr><td style="text-align:left">1.0.*</td><td style="text-align:left">2.0.*</td><td>0.9.<em>.\</em></td></tr><tr><td style="text-align:left">N/A *</td><td style="text-align:left">1.3.*</td><td>0.8.2.2</td></tr></tbody></table><p>说明:大于0.10.2.0版本的kafka客户端，都可以与更旧版本kafka服务端通信，所有大于<code>0.10.x.x</code>推荐按使用spring-kafka 版本 1.3.x 或以上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://spring.io/projects/spring-kafka#learn" target="_blank" rel="noopener">spring-kafka</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;spring和kafka的集成的三种方式&quot;&gt;&lt;a href=&quot;#spring和kafka的集成的三种方式&quot; class=&quot;headerlink&quot; title=&quot;spring和kafka的集成的三种方式&quot;&gt;&lt;/a&gt;spring和kafka的集成的三种方式&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="kafka" scheme="http://tonnyone.github.io/categories/kafka/"/>
    
    
      <category term="java" scheme="http://tonnyone.github.io/tags/java/"/>
    
      <category term="kafka" scheme="http://tonnyone.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka 学习系列 04--kafka的事务处理机制</title>
    <link href="http://tonnyone.github.io/2018/06/12/kafka/kafka5/"/>
    <id>http://tonnyone.github.io/2018/06/12/kafka/kafka5/</id>
    <published>2018-06-12T02:10:00.000Z</published>
    <updated>2021-01-11T21:33:44.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>kafka提供了<code>at-least-once</code> 至少一次的语义保证。多余的消息可能由于生产者重试, 消费者失败重启等原因造成的。kakf-client 在<code>0.11.0.0</code>版本加入了对事务的支持提供了<code>exactly-once</code>的语义.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.confluent.io/blog/transactions-apache-kafka/" target="_blank" rel="noopener">transations-apache-kafka</a></li><li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Transactional+Messaging+in+Kafka" target="_blank" rel="noopener">Transactional+Messaging+in+kafka</a></li><li><a href="https://hevodata.com/blog/kafka-exactly-once/" target="_blank" rel="noopener">KafKa-exactly-onece</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;kafka提供了&lt;code&gt;at-least-once&lt;/code&gt; 至少一次的语义保证。多余的消息可能由于生产者重试, 消费者失败重启等原
      
    
    </summary>
    
      <category term="kafka" scheme="http://tonnyone.github.io/categories/kafka/"/>
    
    
      <category term="java" scheme="http://tonnyone.github.io/tags/java/"/>
    
      <category term="kafka" scheme="http://tonnyone.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka 学习系列 03-kafka消费者</title>
    <link href="http://tonnyone.github.io/2018/06/04/kafka/kafka3/"/>
    <id>http://tonnyone.github.io/2018/06/04/kafka/kafka3/</id>
    <published>2018-06-04T02:10:00.000Z</published>
    <updated>2021-01-11T21:33:44.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消费者群组"><a href="#消费者群组" class="headerlink" title="消费者群组"></a>消费者群组</h2><p>为了横向伸缩,同属于一个组内的消费者只消费一个主题的部分消息，多个消费者可以对消息进行分流.Topic分区中消息只能由消费者组中的唯一个消费者处理(正常情况分区数量应该大于等于消费者数量,否则会有消费者会闲置)</p><p><img src="/uploads/kafka/kafka_consumer.png" alt=""></p><a id="more"></a><h3 id="消费者群组以及分区再均衡"><a href="#消费者群组以及分区再均衡" class="headerlink" title="消费者群组以及分区再均衡"></a>消费者群组以及分区再均衡</h3><p>群组的消费者共同读取主题中的分区，当一个新的消费者加入群组或者当一个消费者被关闭或崩溃时，它就离开群组.分区的所有权从一个消费者转移到另一个消费者，这样的行为称为<code>分区再均衡</code>.</p><ol><li>消费者通过向指派为<code>群组协调器</code>的broker(不同的群主有不同的群组协调器)发送心跳.来维持他们和群主的从属关系以及它们对分区的所有权关系</li><li>只要消费者正常的时间间隔发送心跳，就被<code>协调器</code>认为是活跃的。</li><li>消费者会在轮询消息或者提交偏移量的时候发送心跳</li><li>如果消费者停止发送心跳的时间过长会话就会过期, <code>群组协调器</code>会认为其已经死亡,就会触发一次再均衡。</li><li>如果一个消费者发生死亡，群主协调器会等待几秒钟确定死亡了，才会触发再均衡。在这几秒钟的时间里，死亡的消费者不会消费分区中的消息。在清理消费者时，消费者会通知<code>群组协调器</code>它要离开群组，立即触发一次分区再均衡。</li></ol><p>分配分区的过程:</p><p><img src="/uploads/kafka/kafka_consumer2.png" alt=""></p><ol><li>当消费者要加入群组时，会向<code>群组协调器</code>发送一个JoinGroup 请求,第一个加入群组的消费者将成为<code>群主</code></li><li>群主从协调器那里获得群组成员列表(列表中包含了最近发送心跳的消费者，它被认为时活跃的)，并负责给每个消费者分配分区。</li><li>群主使用一个实现了PartitionAssignor接口的类来决定哪些分区要被分配给哪个消费者。</li><li>分配结束后群主把分配情况发送给<code>群组协调器</code>,协调器再把这些信息发送给所有消费者。每个消费者只能看到自己的分配信息，群主知道群组里面所有消费者的分配情况。</li><li>这个过程每次分区再均衡的时候发生一次</li></ol><h2 id="kafka-消费者API"><a href="#kafka-消费者API" class="headerlink" title="kafka 消费者API"></a>kafka 消费者API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>,<span class="string">"192.168.200.219:19092"</span>);</span><br><span class="line">props.put(<span class="string">"group.id"</span>,<span class="string">"testgroup2"</span>);</span><br><span class="line">props.put(<span class="string">"key.deserializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.deserializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"></span><br><span class="line">KafkaConsumer&lt;String,String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String,String&gt;(props);</span><br><span class="line"><span class="comment">// 1. 消费者订阅主题，此处一次订阅多个主题，或者可以使用正则表达式</span></span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"test"</span>));</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 2. 消费者必须持续向kafka轮询，否则就会被认为死亡。</span></span><br><span class="line">    ConsumerRecords&lt;String, String&gt; cr = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : cr) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"record:%s \n"</span>,record.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 3.在退出程序之前使用close()方法关闭消费者。</span></span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>消费者订阅主题,可以同时订阅多个主题，或者使用正则表达式</li><li><code>poll()</code>方法轮询kafka获取数据(必须持续的对kafka进行轮询否则消费者会被认为已经死亡,轮询不止获取数据这么简单，在第一次调用poll方法的时候，它会负责查找GroupCoordinator,然后加入群组，接受分配的分区，如果发生了在均衡整个过程也是在轮询期间进行的。当然心跳也是从轮询中发送出去的，所以我们应该确保轮询期间所做的任何工作尽快完成)。<code>poll</code>方法包含一个参数控制阻塞的超时时间。该参数如果设置为0，poll方法立即返回。否则它会在指定的毫秒数内一直等待broker返回数据。<code>poll</code>会返回一个记录列表.每条记录包含了主题记录的信息(分区信息，偏移量，键值对).无论是否有数据，<code>poll</code>方法都会返回，超时时间取决于应用程序对响应速度的要求，</li><li>在退出程序之前使用close()关闭消费者。网络连接和socket随即会被关闭。并立即触发一次再均衡,而不是等待群组协调器发现它不在发送心跳并认定已死亡，因为那样需要更长时间，导致整个群组再一段时间内无法读取消息。</li></ol><h3 id="提交和偏移量"><a href="#提交和偏移量" class="headerlink" title="提交和偏移量"></a>提交和偏移量</h3><p>kafka 是如何记录消费者的偏移量的呢？ 在早期的版本里面消费者的偏移量是记录在<code>zookeeper</code>里面的，从0.9版本开始，偏移量记录在一个名为<code>__consumer_offset</code>的topic里面.如果消费者发生崩溃或者有新的消费者加入群组，就会触发在均衡。完成再均衡后，每个消费者可能分配到新的分区。消费者读取此分区最后一次的提交偏移量,继续处理</p><ol><li>如果之前的消费者消费了消息但是来不及提交崩溃了，再均衡的时候，未提交偏移量的这部分消费会被重复处理。(这就是kakfa本身不能保证消息只被处理一次的原因)。</li><li>消费者也可以提交大于它当前正处理消息的偏移量，跳过某些消息。</li></ol><h4 id="自动提交偏移量"><a href="#自动提交偏移量" class="headerlink" title="自动提交偏移量"></a>自动提交偏移量</h4><p>如果消费者的<code>enable.auto.commit</code> 的配置项被设置为 <code>true</code> ,那么消费者会默认每隔<code>5s</code>就会自动把从poll接收到的最大偏移量提交上去。提交时间由<code>auto.commit.interval.ms</code>控制，单位为秒.<br>自动提交偏移量也是发生在轮询中，每次轮询，消费者会检测是否到了该提交偏移量了的时候，如果是，那么提交上次poll返回的偏移量。如果在最近一次提交后3s发生了<code>再均衡</code>,那么待消费者重新分配完分区后这3s的消费就会被重复处理。</p><h4 id="手动提交偏移量"><a href="#手动提交偏移量" class="headerlink" title="手动提交偏移量"></a>手动提交偏移量</h4><p>消费者把<code>auto.commit.offset</code>设置为<code>false</code>,可以手动控制偏移量</p><h5 id="同步提交"><a href="#同步提交" class="headerlink" title="同步提交"></a>同步提交</h5><p><code>commitSync()</code>方法会将上次poll方法返回的偏移量提交。只要没有发生不可恢复的错误，commitSync()方法会一直尝试提交直到成功。如果提交失败，我们可以把错误日志记录下来。如果在提交过程中发生再均衡，最近的一批消息在再均衡后还会被重复处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">//2. 消费者必须持续向kafka轮询，否则就会被认为死亡。</span></span><br><span class="line">    ConsumerRecords&lt;String, String&gt; cr = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : cr) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"record:%s \n"</span>,record.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4 .同步提交</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h5><p><code>commitAsync</code> 方法不会重试，这是异步提交不好的一个地方。不重试的原因是，可能在此次提交失败后，另一个更大的偏移量已经提交.<code>commitAsync</code>支持回调，在broker做出响应的时候会执行回调。回调一般用于记录提交错误或者生成指标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">//2. 消费者必须持续向kafka轮询，否则就会被认为死亡。</span></span><br><span class="line">    ConsumerRecords&lt;String, String&gt; cr = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : cr) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"record:%s \n"</span>,record.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4 .异步提交</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(exception!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">"提交失败\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同步加异步提交"><a href="#同步加异步提交" class="headerlink" title="同步加异步提交"></a>同步加异步提交</h5><p>一般情况下，针对偶尔出现的提交失败，不进行重试不会有太大的问题，因为如果提交失败是由临时问题导致的，那么后续的提交总是会成功的。因此消费者关闭前，一般会组合使用同步和异步提交，这样确保最后一次提交能够成功。如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//2. 消费者必须持续向kafka轮询，否则就会被认为死亡。</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; cr = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : cr) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"record:%s \n"</span>,record.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.在退出程序之前使用close()方法关闭消费者。</span></span><br><span class="line">        consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提交特定的偏移量"><a href="#提交特定的偏移量" class="headerlink" title="提交特定的偏移量"></a>提交特定的偏移量</h4><p>之前提交的方式都是按照<code>poll()</code>方法同步，按照如果想根据按照消息数量来提交。下面的方法每隔<code>1000</code>条消息提交偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1. 用于跟踪各个分区的偏移量</span></span><br><span class="line">Map&lt;TopicPartition,OffsetAndMetadata&gt; currentOffsets = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//2. 消费者必须持续向kafka轮询，否则就会被认为死亡</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; cr = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : cr) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"record:%s \n"</span>,record.toString());</span><br><span class="line">            currentOffsets.put(<span class="keyword">new</span> TopicPartition(record.topic(),record.partition()),<span class="keyword">new</span> OffsetAndMetadata(record.offset()+<span class="number">1</span>,<span class="string">"no metadata"</span>));</span><br><span class="line">            <span class="comment">// 3. 如果消费数量到1000 就提交偏移量</span></span><br><span class="line">            <span class="keyword">if</span>(count % <span class="number">1000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                consumer.commitAsync();</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//4.在退出程序之前使用close()方法关闭消费者。</span></span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再均衡监听器"><a href="#再均衡监听器" class="headerlink" title="再均衡监听器"></a>再均衡监听器</h3><ol><li>实现ConsumerRebalanceListener接口</li><li>如果发生再均衡，先要把即将失去的分区读取的偏移量全部都体提交。</li><li>消费者订阅消息的时候把<code>ConsumerRebalanceListener</code>传给<code>subscribe()</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;TopicPartition,OffsetAndMetadata&gt; currentOffsets = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> KafkaConsumer&lt;String,String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String,String&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实现ConsumerRebalanceListener 接口,实现消费者再均衡监听器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleRebalance</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">kafka</span>.<span class="title">clients</span>.<span class="title">consumer</span>.<span class="title">ConsumerRebalanceListener</span></span>&#123;</span><br><span class="line">    <span class="comment">//2. 方法会在再均衡开始之前和消费者停止读取消息之后被调用,在这里提交已经读取的偏移量，下一个接管分区的消费者就会继续从这里开始读取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Lost paritions in rebalance,commit current offset"</span>+currentOffsets);</span><br><span class="line">        consumer.commitSync(currentOffsets);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 方法会在在均衡之后，就是重新分配分区之后，新的消费者开始读取消息之前被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 注册再均衡监听器</span></span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"test"</span>),<span class="keyword">new</span> HandleRebalance());</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//5. 消费者必须持续向kafka轮询，否则就会被认为死亡</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; cr = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : cr) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"record:%s \n"</span>,record.toString());</span><br><span class="line">            currentOffsets.put(<span class="keyword">new</span> TopicPartition(record.topic(),record.partition()),<span class="keyword">new</span> OffsetAndMetadata(record.offset()+<span class="number">1</span>,<span class="string">"no metadata"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync(currentOffsets,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (WakeupException e)&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//6.在退出程序之前使用close()方法关闭消费者。</span></span><br><span class="line">        consumer.commitSync(currentOffsets);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">        System.out.println(<span class="string">"consumer has been Closed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从特定的偏移量开始处理记录"><a href="#从特定的偏移量开始处理记录" class="headerlink" title="从特定的偏移量开始处理记录"></a>从特定的偏移量开始处理记录</h3><p>api 提供了<code>seekToBeginning(Collection&lt;TopicPartition&gt;, tp)</code> 和 <code>seekToEnd(Collection&lt;TopicPartition&gt; tp)</code>,<code>seek()</code>等方法，可以直接跳转到指定的位置进行读取记录。有人尝试把偏移量保存到数据库里面，让处理数据和提交偏移量再一个事务里面处理，这样保证了数据的完整和唯一性。</p><h3 id="如何退出"><a href="#如何退出" class="headerlink" title="如何退出"></a>如何退出</h3><p>如果消费者要退出循环.唯一一个可以从其他线程安全调用的方法<code>consumer.wakeup()</code>。调用<code>consumer.wakeup()</code>可以退出poll().并抛出WakeupException异常，如果效用consumer.wakeup()时，线程没有再等待poll方法，那么他会在下一轮循环跳出。在退出线程之前调用<code>consumer.close()</code>时必要的，它会提交任何没有提交的东西，并且向群组协调器发送消息，告知自己要离开群组，触发再均衡，而不需要等待会话超时。</p><h3 id="消费者关键配置一览"><a href="#消费者关键配置一览" class="headerlink" title="消费者关键配置一览"></a>消费者关键配置一览</h3><h4 id="fetch-min-bytes"><a href="#fetch-min-bytes" class="headerlink" title="fetch.min.bytes"></a><code>fetch.min.bytes</code></h4><p>该属性指定了消费者从服务器获取记录的最小字节数。当broker收到消费者数据请求时，如果可用的数据量小宇fetch.min.bytes指定大小，那么它会等到有足够的可用数据时才把它返回给消费者.</p><h4 id="fetch-max-wait-ms"><a href="#fetch-max-wait-ms" class="headerlink" title="fetch.max.wait.ms"></a><code>fetch.max.wait.ms</code></h4><p>此配置用于指定broker的等待时间，默认是<code>500ms</code>,如果没有足够的数据流入kafka,消费者获取的最小数据量达不到满足，到500ms,就会返回给消费者.</p><h4 id="max-partition-fetch-bytes"><a href="#max-partition-fetch-bytes" class="headerlink" title="max.partition.fetch.bytes"></a><code>max.partition.fetch.bytes</code></h4><p>此配置指定了服务器从每个分区返回给消费者的最大字节数，默认值为<code>1M</code>,即<code>poll()</code>方法从每个分区返回的记录最多不超过<code>max.partition.fethc.bytes</code>指定的字节数。</p><h4 id="session-timeout-ms"><a href="#session-timeout-ms" class="headerlink" title="session.timeout.ms"></a><code>session.timeout.ms</code></h4><p>该属性指定了消费者被认为死亡之前可以与服务器断开的连接时间,默认为<code>3s</code>,也就是说如果没有在<code>session.timeout.ms</code>指定的时间内发送心跳给群组协调器，就会被认为死亡触发再均衡。该属性与<code>heartbeat.interval.ms</code>密切相关。<code>heartbeat.interval.ms</code>指定了<code>poll()</code>方法向协调器发送心跳的频率。所以<code>heartbeat.interval.ms</code>一定要比<code>session.timeout.ms</code>小，一般为<code>session.timout.ms</code>的三分之一。</p><h4 id="auto-offset-reset"><a href="#auto-offset-reset" class="headerlink" title="auto.offset.reset"></a><code>auto.offset.reset</code></h4><p>该属性指定了消费者再读取一个没有偏移量的分区或者偏移量无效的情况下，该作何处理,默认值为<code>lastest</code>,从最新的记录开始读取,另一个值<code>earliest</code>,意思说，在偏移量无效的情况下，从起始位置开始读取</p><h4 id="enable-auto-commit"><a href="#enable-auto-commit" class="headerlink" title="enable.auto.commit"></a><code>enable.auto.commit</code></h4><p>指定了消费者是否自动提交偏移量,默认为<code>true</code>,可以设置为<code>false</code>,进行手动提交</p><h4 id="partition-assignmeng-strategy"><a href="#partition-assignmeng-strategy" class="headerlink" title="partition.assignmeng.strategy"></a><code>partition.assignmeng.strategy</code></h4><p>分区分配策略,默认kafka有两种<code>Range</code>和<code>RoundRobin</code>,当然可以自定义</p><h4 id="client-id"><a href="#client-id" class="headerlink" title="client.id"></a><code>client.id</code></h4><p>broker用它来表示从客户端发送过来的消息，通常用在日志，指标监控中。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Index" target="_blank" rel="noopener">kafka 官网</a></li><li><a href="https://book.douban.com/subject/27665114/" target="_blank" rel="noopener">kafka 权威指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;消费者群组&quot;&gt;&lt;a href=&quot;#消费者群组&quot; class=&quot;headerlink&quot; title=&quot;消费者群组&quot;&gt;&lt;/a&gt;消费者群组&lt;/h2&gt;&lt;p&gt;为了横向伸缩,同属于一个组内的消费者只消费一个主题的部分消息，多个消费者可以对消息进行分流.Topic分区中消息只能由消费者组中的唯一个消费者处理(正常情况分区数量应该大于等于消费者数量,否则会有消费者会闲置)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/kafka/kafka_consumer.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="kafka" scheme="http://tonnyone.github.io/categories/kafka/"/>
    
    
      <category term="java" scheme="http://tonnyone.github.io/tags/java/"/>
    
      <category term="kafka" scheme="http://tonnyone.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka 学习系列 02-kafka生产者</title>
    <link href="http://tonnyone.github.io/2018/05/20/kafka/kafka2/"/>
    <id>http://tonnyone.github.io/2018/05/20/kafka/kafka2/</id>
    <published>2018-05-20T14:00:00.000Z</published>
    <updated>2021-01-11T21:33:44.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kafka-生产者流程"><a href="#kafka-生产者流程" class="headerlink" title="kafka 生产者流程"></a>kafka 生产者流程</h2><p><img src="/uploads/kafka/kafka_producer.png" alt=""></p><ol><li>创建一个ProductRecord对象(对象包含主题名称,分区,key,value).</li><li>把key和value 序列化成字节数组.</li><li>如果ProductRecord对象没有指定了分区,那么分区器会通过key选择一个分区,如果指定了分区的话直接返回</li><li>被序列化后的这条记录会被发往一个记录批次里,这个批次里面的所有消息都是发往相同的主题和相同的分区的</li><li>会有专门的线程把这些记录批次发到响应的broker上</li><li>服务器收到消息会返回一个响应,如果写如成功就会返回一个RecordMetaData对象(包含了主题和分区信息以及分区的偏移量)</li><li>如果不成功,则会返回一个错误,某些错误在生者收到后会重新尝试发送消息,几次后如果还是失败,就返回失败信息</li></ol><a id="more"></a><h3 id="生产者API解析"><a href="#生产者API解析" class="headerlink" title="生产者API解析"></a>生产者API解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>,<span class="string">"192.168.200.219:19092"</span>);</span><br><span class="line">props.put(<span class="string">"key.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">KafkaProducer producer = <span class="keyword">new</span> KafkaProducer&lt;String,String&gt;(props);</span><br><span class="line"></span><br><span class="line">String topic = <span class="string">"test"</span>;</span><br><span class="line">ProducerRecord&lt;String,String&gt; producerRecord = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(topic,<span class="string">"1"</span>,<span class="string">"nihao"</span>);</span><br><span class="line">producer.send(producerRecord);</span><br></pre></td></tr></table></figure><h4 id="关键方法send发送消息的三种方式"><a href="#关键方法send发送消息的三种方式" class="headerlink" title="关键方法send发送消息的三种方式"></a>关键方法<code>send</code>发送消息的三种方式</h4><ol><li>发送不管无论结果是否成功</li><li>发送消息后阻塞直到消息发送成功</li><li>发送消息,异步获取成功结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 直接发送,无论是否成功</span></span><br><span class="line">producer.send(producerRecord);</span><br><span class="line"><span class="comment">//2. 获取future,阻塞获取结果</span></span><br><span class="line">Future&lt;RecordMetadata&gt; future = producer.send(producerRecord);</span><br><span class="line">RecordMetadata recordMetadata = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  recordMetadata = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"发送成功"</span>+recordMetadata.toString());</span><br><span class="line"><span class="comment">//3. 成功后执行回调</span></span><br><span class="line">producer.send(producerRecord, <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"发送成功CallBack:"</span>+recordMetadata.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="生产者关键配置"><a href="#生产者关键配置" class="headerlink" title="生产者关键配置"></a>生产者关键配置</h3><h4 id="bootstrap-servers"><a href="#bootstrap-servers" class="headerlink" title="bootstrap.servers"></a><code>bootstrap.servers</code></h4><p>broker地址清单，生产者会从给定的groker里面查找到其他的broker的信息。建议配置多个，一旦其中一个宕机，生产者仍然能够连到集群上。</p><h4 id="key-serializer"><a href="#key-serializer" class="headerlink" title="key.serializer"></a><code>key.serializer</code></h4><p>必须 设置为 <code>org.apache.kafka.common.serialization.Serializer</code>接口类，用于将消息key序列化为字节数组</p><h4 id="value-serializer"><a href="#value-serializer" class="headerlink" title="value.serializer"></a><code>value.serializer</code></h4><p>必须 设置为 <code>org.apache.kafka.common.serialization.Serializer</code>接口类，用于将消息value序列化为字节数组</p><h4 id="acks"><a href="#acks" class="headerlink" title="acks"></a><code>acks</code></h4><p>指定了集群中多少个分区副本收到消息,生产者才认为消息是写入成功的.</p><ol><li>acks=0 生产者不会等待任何分区副本的确认，如果配置<code>retries</code>,则配置无效,如果写入错误生产者是获取不到的,返回的offset永远都是<code>-1</code>.</li><li>acks=1 只要分区副本的<code>leader</code>被写入消息后,生产者就会认为消息写入成功.如果消息无法到达<code>leader</code>(比如leader崩溃后还没有选举出来),生产者会收到错误的响应重发,但是如果写入<code>leader</code>的消息没来得及同步到其他副本,挂掉了，此时还是会发生消息丢失.</li><li>acks=all 只有全部参与复制的节点收到都收到消息后才认为消息写入是成功的,就算有副本发生崩溃整个集群仍然可用.不过此选项写入消息的延迟会更高。</li></ol><h4 id="buffer-memory"><a href="#buffer-memory" class="headerlink" title="buffer.memory"></a><code>buffer.memory</code></h4><p>用来设置生产者消息内存缓冲区的大小.如果消息发送的太快，就会导致缓冲区的空间不足.这个时候<code>send</code>方法要么被阻塞，要么抛出异常.<code>max.blocks.ms</code>设置了可阻塞的时长.</p><h4 id="compression-type"><a href="#compression-type" class="headerlink" title="compression.type"></a><code>compression.type</code></h4><p>压缩类型,指定了发送给broker的消息压缩算法,压缩可以降低网络传输和存储的开销,但是增加了CPU的计算压力</p><ul><li>none</li><li>gzip</li><li>anappy</li><li>lz4</li></ul><h4 id="retries"><a href="#retries" class="headerlink" title="retries"></a><code>retries</code></h4><p>重试次数: 生产者发送从服务器收到的错误消息可能是临时性的错误(比如分区找不到Leader),这种情况,retrise参数决定了生产者可以重试的次数,如果达到这个次数生产者会放弃重试，返回错误,默认情况重试会等待100ms,可以通过<code>retry.badkoff.ms</code>来修改.不过有些错误不是临时错误,比如(消息太大的错误),业务处理一般只处理不可重试的错误,或者重试次数超出上限的情况.如果设置了</p><h4 id="batch-size"><a href="#batch-size" class="headerlink" title="batch.size"></a><code>batch.size</code></h4><p>当多个消息被发送到同一个分区的时候，生产者会把它放入到一个批次当中提交，该参数指定了一个批次可使用的内存大小，按照字节数计算，当批次被填满是就会被发送出去，不过生产者生产者并不一定会等批次被填满才会去发送,详见<code>linger.ms</code>参数， 所以就算把批次设置的很大也不会造成延迟，只会增加更多多的内存而已，但是如果设置的很小，生产者就会频繁的发送消息，会增加额外的开销</p><h4 id="linger-ms"><a href="#linger-ms" class="headerlink" title="linger.ms"></a><code>linger.ms</code></h4><p>该参数指定了生产者在发送批次之前等待更多消息加入批次的时间，生产者会在批次被填满或者等待时间达到该参数的值的时候消息被发送出去。把<code>linger.ms</code>设置为比0大的值，让生产者发送到批次的时候等待一会儿，虽然这样会增加延迟，但是会提高kafka的吞吐量.</p><h4 id="client-id"><a href="#client-id" class="headerlink" title="client.id"></a><code>client.id</code></h4><p>该参数如果被设置，服务器会用来标识消息的来源</p><h4 id="max-block-ms"><a href="#max-block-ms" class="headerlink" title="max.block.ms"></a><code>max.block.ms</code></h4><p>该参数指定在调用send方法或使用partitionFor方法获取元数据的时候，生产者的阻塞时间。当生产者发送的缓存区已满，或者没有可用的元数据时，方法就会阻塞，阻塞时间达到<code>max.block.ms</code>时，生产者会抛出异常</p><h4 id="max-request-size"><a href="#max-request-size" class="headerlink" title="max.request.size"></a><code>max.request.size</code></h4><p>生产者发送单个消息的最大值,也可以指单个请求中所有消息的大小。另外，broker对可接收消息最大值也有自己的限制<code>message.max.bytes</code>指一个批次发送到broker的最大值，这个值应该是<code>max.request.size</code>的整数倍</p><h4 id="max-in-flight-requests-per-connection"><a href="#max-in-flight-requests-per-connection" class="headerlink" title="max.in.flight.requests.per.connection"></a><code>max.in.flight.requests.per.connection</code></h4><p>该参数指定了生产者在服务器收到响应之前可以发送多少个消息。它的值越大就会占用越多的内存提高吞吐量。把它设置为1 可以保证消息是按照顺序写入服务器的，但是如果retries不为0的话，消息的先后顺序会发生错位,假设第一条消息失败了，第二条先发送成功了，然后第一条又重试成功了，这个时候发送的服务器的顺序就出现了错位。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Index" target="_blank" rel="noopener">kafka 官网</a></li><li><a href="https://book.douban.com/subject/27665114/" target="_blank" rel="noopener">kafka 权威指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kafka-生产者流程&quot;&gt;&lt;a href=&quot;#kafka-生产者流程&quot; class=&quot;headerlink&quot; title=&quot;kafka 生产者流程&quot;&gt;&lt;/a&gt;kafka 生产者流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/uploads/kafka/kafka_producer.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个ProductRecord对象(对象包含主题名称,分区,key,value).&lt;/li&gt;
&lt;li&gt;把key和value 序列化成字节数组.&lt;/li&gt;
&lt;li&gt;如果ProductRecord对象没有指定了分区,那么分区器会通过key选择一个分区,如果指定了分区的话直接返回&lt;/li&gt;
&lt;li&gt;被序列化后的这条记录会被发往一个记录批次里,这个批次里面的所有消息都是发往相同的主题和相同的分区的&lt;/li&gt;
&lt;li&gt;会有专门的线程把这些记录批次发到响应的broker上&lt;/li&gt;
&lt;li&gt;服务器收到消息会返回一个响应,如果写如成功就会返回一个RecordMetaData对象(包含了主题和分区信息以及分区的偏移量)&lt;/li&gt;
&lt;li&gt;如果不成功,则会返回一个错误,某些错误在生者收到后会重新尝试发送消息,几次后如果还是失败,就返回失败信息&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="kafka" scheme="http://tonnyone.github.io/categories/kafka/"/>
    
    
      <category term="java" scheme="http://tonnyone.github.io/tags/java/"/>
    
      <category term="kafka" scheme="http://tonnyone.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka 学习系列 01-kafka的基本概念和常用命令</title>
    <link href="http://tonnyone.github.io/2018/05/17/kafka/kafka/"/>
    <id>http://tonnyone.github.io/2018/05/17/kafka/kafka/</id>
    <published>2018-05-17T14:00:00.000Z</published>
    <updated>2021-01-11T21:33:44.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ol><li>Kafka 无论消息是否被消费都保存所有的消息,除非消息过期.</li><li>消费者持有的数据就是消息的偏移量,偏移量由消费者控制,所以消费者可以重新读取每一条消息.</li></ol><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>Log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。 根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个leader，零或多个follower。Leader处理此分区的所有的读写请求，而follower只是被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区的leader，另一个分区的follower。</p><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>生产者往某个Topic上发布消息。生产者也负责选择发布到Topic上的哪一个分区。最简单的方式从分区列表中轮流选择。也可以根据某种算法依照权重选择分区。开发者负责如何选择分区的算法。</p><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了<strong>queue模型</strong>。假如所有的消费者都在不同的组中，那么就完全变成了<strong>发布-订阅</strong>模型</p><ul><li>像传统的消息系统一样，Kafka保证消息的顺序不变</li><li>Topic分区中消息只能由消费者组中的唯一个消费者处理(正常情况分区数量应该大于等于消费者数量,否则会有消费者会闲置)</li><li>kafka 保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</li></ul><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://kafka.apache.org/downloads.html" target="_blank" rel="noopener">kafka官网下载</a><br><a href="https://kafka.apache.org/quickstart" target="_blank" rel="noopener">安装步骤</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>说明:</strong>以下命令都是运行再0.9以上版本,0.9之前的版本消费者的偏移量是存储在zookeeper 下的,0.9或以上版本,消费者的偏移存储到了kafka的一个内部topic里面<code>__consumer_offsets</code>里面,<br>0.9不光指服务端版本,只有服务端和客户端都使用0.9或以上版本,偏移才会存在kafka中.</p><p><a href="https://cwiki.apache.org/confluence/display/KAFKA/System+Tools" target="_blank" rel="noopener">官网提供的常用的维护工具</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建topic,指定副本数和分区数</span></span><br><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看已经创建的topic</span></span><br><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看topic详细信息</span></span><br><span class="line">bin/kafka-topics.sh --zookeeper localhost:2181 --describe --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产消息</span></span><br><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群消费消息,并指定最大消费数</span></span><br><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --zookeeper localhost:2181 --topic <span class="built_in">test</span> --from-beginning --new-consumer --max-messages 12</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有的消费者groups</span></span><br><span class="line">bin/kafka-consumer-groups.sh --zookeeper 192.168.200.219:2181 --list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9.0之前版本查看消费者的offset</span></span><br><span class="line">bin/zookeeper-shell.sh localhost:2181 &lt;&lt;&lt; <span class="string">"get /consumers/sc_group1/offsets/static_status_topic/0"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.0之前版本重新设定消费者的offset</span></span><br><span class="line">bin/zookeeper-shell.sh localhost:2181 &lt;&lt;&lt; <span class="string">"set /consumers/sc_group1/offsets/static_status_topic/0 3402200"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询指定消费者的offset</span></span><br><span class="line">bin/kafka-consumer-groups.sh --zookeeper 192.168.200.219:2181 --group sc_group1 --describe</span><br><span class="line"><span class="comment"># 0.9.0,0.10 目前没有官方提供的系统工具用于重置offset,0.11 版本下面命令行可以重置offset</span></span><br><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server &lt;kafkahost:port&gt; --group &lt;group_id&gt; --topic &lt;topic_name&gt; --reset-offsets --to-earliest --execute</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.zhihu.com/question/56172498/answer/148006508" target="_blank" rel="noopener">kafka 推荐书籍</a></li><li><a href="http://orchome.com/454" target="_blank" rel="noopener">kafka 命令</a></li><li><a href="http://orchome.com/18" target="_blank" rel="noopener">kafka 教程</a></li><li><a href="https://book.douban.com/subject/27665114/" target="_blank" rel="noopener">kafka 权威指南</a></li><li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Index" target="_blank" rel="noopener">kafka 官网</a></li><li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Replication+tools" target="_blank" rel="noopener">kafka Replication+tools</a></li><li><a href="https://elang2.github.io/myblog/posts/2017-09-20-Kafak-And-Zookeeper-Offsets.html" target="_blank" rel="noopener">kafka and zookeeper offset</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Kafka 无论消息是否被消费都保存所有的消息,除非消息过期.&lt;/li&gt;
&lt;li&gt;消费者持有的数据就是消息的偏移量,偏移量由消费者控制,所以消费者可以重新读取每一条消息.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;分布式&quot;&gt;&lt;a href=&quot;#分布式&quot; class=&quot;headerlink&quot; title=&quot;分布式&quot;&gt;&lt;/a&gt;分布式&lt;/h3&gt;&lt;p&gt;Log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。 根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个leader，零或多个follower。Leader处理此分区的所有的读写请求，而follower只是被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区的leader，另一个分区的follower。&lt;/p&gt;
&lt;h3 id=&quot;生产者&quot;&gt;&lt;a href=&quot;#生产者&quot; class=&quot;headerlink&quot; title=&quot;生产者&quot;&gt;&lt;/a&gt;生产者&lt;/h3&gt;&lt;p&gt;生产者往某个Topic上发布消息。生产者也负责选择发布到Topic上的哪一个分区。最简单的方式从分区列表中轮流选择。也可以根据某种算法依照权重选择分区。开发者负责如何选择分区的算法。&lt;/p&gt;
&lt;h3 id=&quot;消费者&quot;&gt;&lt;a href=&quot;#消费者&quot; class=&quot;headerlink&quot; title=&quot;消费者&quot;&gt;&lt;/a&gt;消费者&lt;/h3&gt;&lt;p&gt;消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了&lt;strong&gt;queue模型&lt;/strong&gt;。假如所有的消费者都在不同的组中，那么就完全变成了&lt;strong&gt;发布-订阅&lt;/strong&gt;模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;像传统的消息系统一样，Kafka保证消息的顺序不变&lt;/li&gt;
&lt;li&gt;Topic分区中消息只能由消费者组中的唯一个消费者处理(正常情况分区数量应该大于等于消费者数量,否则会有消费者会闲置)&lt;/li&gt;
&lt;li&gt;kafka 保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="kafka" scheme="http://tonnyone.github.io/categories/kafka/"/>
    
    
      <category term="java" scheme="http://tonnyone.github.io/tags/java/"/>
    
      <category term="kafka" scheme="http://tonnyone.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>java 并发01-synchoronized与volatile</title>
    <link href="http://tonnyone.github.io/2018/05/10/javabase/bingfa1/"/>
    <id>http://tonnyone.github.io/2018/05/10/javabase/bingfa1/</id>
    <published>2018-05-10T08:50:10.000Z</published>
    <updated>2021-01-11T21:33:44.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="synchoronized-内置锁"><a href="#synchoronized-内置锁" class="headerlink" title="synchoronized(内置锁)"></a>synchoronized(内置锁)</h2><p>内置锁的含义为： 在代码进入同步块的时候获取对象的锁，退出代码块后释放锁.<br>如果线程A尝试获取线程B的持有的锁，线程A必须等待或者阻塞.只有线程B释放锁(离开代码块或者抛出异常),线程A才能获得锁，如果线程B不释放锁,线程A将永远等待下去.</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile一般用作标记一个java变量<strong>保存在主存</strong>中,而不是缓存.这就意味着每一个读取volatile变量的线程是从主存读取,</p><a id="more"></a><h2 id="syncoronized-的用法"><a href="#syncoronized-的用法" class="headerlink" title="syncoronized 的用法"></a>syncoronized 的用法</h2><ul><li>synchoronized 方法</li></ul><ol><li>如果synchonized加在方法上，则锁定的是当前的对象(不可加在构造方法上面)</li><li>如果synchonized加在静态方法上，锁定的是Class对象</li></ol><ul><li>synchoronized 声明</li></ul><p>获得括号内的对象的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果count是Synchronized的一个实例对象,synchonized 有两层含义:</p><ol><li>保证了只有一个线程可以获得count的锁,所有其他的线程执行synchonized的方法都会挂起，直到一个线程执行完毕或者抛出异常,保证了<strong>原子性</strong></li><li>保证了当同步方法执行完毕后,synchronized关键字对count对象建立一个<strong>happen-before</strong>的关系,确保内存<strong>可见性</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son do sometion"</span>);</span><br><span class="line">        <span class="keyword">super</span>.doTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中son的doTest方法调用了父类的doTest()方法,son线程试图获取一个已经由它自己持有的锁,那么这个请求一定会成功.这就是锁的<strong>重入性</strong>,如果内置锁不是可重入的,那么上面代码会发生死锁,因为son的持有线程等待一个释放不了的锁。</p><h2 id="volatile-的用法"><a href="#volatile-的用法" class="headerlink" title="volatile 的用法"></a>volatile 的用法</h2><p>volatile变量提供了一种弱一点的同步机制.一般用于检查某个状态标记以判断是否推出循环.示例中,asleep必须为volatile变量.否则当asleep被另一个线程修改时,执行判断的线程却发现不了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> asleep;</span><br><span class="line"><span class="keyword">while</span>(!asleep)</span><br><span class="line">  countSomeSheep();</span><br></pre></td></tr></table></figure><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puzzle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> answerReady = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            answer = <span class="number">42</span>;</span><br><span class="line">            answerReady = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (answerReady)</span><br><span class="line">                System.out.println(<span class="string">"The meaning of life is: "</span> + answer);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"I don't know the answer"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可能输令人匪夷所思的结果: The meaning of life is: 0<br>当answerReady 为true的时候,answer 可能还是 0; 仿佛第6,7行跌倒了执行次序. 为了提升运行效率,编译器内存在不改变单线程执行结果的前提下,重新安排执行顺序:源代码—-&gt;编译器优化重排序—-&gt;指令级并行重排序—-&gt;内存系统重排序—-&gt;最终执行的指令序列.</p><p>volatile 主要语意保证了内存可见性,防止指令重排序</p><p>当且仅当满足以下条件时,才应该使用volatile变量：</p><ol><li>对变量的写入操作不依赖变量的当前值,或者你能确保只有单个线程更新变量的值.</li><li>该变量不会与其他状态变量一起共同参与不变约束.</li><li>访问变量时不需要加锁.</li></ol><p><strong>注意:</strong> 加锁机制既能确保可见性有可以确保原子性,而volatile变量只能确保可见性</p><h2 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a>java 内存模型</h2><h3 id="synchonized-的实现"><a href="#synchonized-的实现" class="headerlink" title="synchonized 的实现"></a>synchonized 的实现</h3><ol><li>synchonized关键字经过编译会在同步代码块的前后形成<strong>monitorenter</strong>和<strong>monitorexit</strong>两个字节码指令</li><li>当执行monitorenter指令的时候,首先尝试获取对象的锁，如果对象没有被锁定,或者当前线程已经拥有了对象的锁,则把锁的计数器加1</li><li>在执行monitorexit指令的时候，会把锁的计数器减1,当计数器为0的时候锁就被释放</li></ol><h3 id="volatile-的实现"><a href="#volatile-的实现" class="headerlink" title="volatile 的实现"></a>volatile 的实现</h3><ol><li>volatile定义的变量保证了变量对所有线程的可见性,可见性是指当一条线程修改这个变量值的话,新值对于其他线程来说是立即可以得到的,而普通变量需要修改后再向主内存回写以后，才对其他变量可见.</li><li>volatile 第二个语义是禁止指令的重排序</li></ol><ul><li>普通变量仅仅会保证方法执行过程中所有依赖赋值结果的地方能获取到正确的结果.但是不能保证变量赋值操作的顺序与程序代码中执行的结果一致.</li><li>volatile修饰的变量会再赋值后执行一个(local addl $0x0, (%esp))这个操作相当于一个内存屏障,指令从排序无法越过内存屏障</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html" target="_blank" rel="noopener">oracle官网文档</a></li><li><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">java 并发编程实战</a></li><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">java 深入理解java虚拟机</a></li><li><a href="https://www.zhihu.com/question/35268028" target="_blank" rel="noopener">知乎关于双重锁检查的讨论</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;synchoronized-内置锁&quot;&gt;&lt;a href=&quot;#synchoronized-内置锁&quot; class=&quot;headerlink&quot; title=&quot;synchoronized(内置锁)&quot;&gt;&lt;/a&gt;synchoronized(内置锁)&lt;/h2&gt;&lt;p&gt;内置锁的含义为： 在代码进入同步块的时候获取对象的锁，退出代码块后释放锁.&lt;br&gt;如果线程A尝试获取线程B的持有的锁，线程A必须等待或者阻塞.只有线程B释放锁(离开代码块或者抛出异常),线程A才能获得锁，如果线程B不释放锁,线程A将永远等待下去.&lt;/p&gt;
&lt;h2 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h2&gt;&lt;p&gt;volatile一般用作标记一个java变量&lt;strong&gt;保存在主存&lt;/strong&gt;中,而不是缓存.这就意味着每一个读取volatile变量的线程是从主存读取,&lt;/p&gt;
    
    </summary>
    
      <category term="java并发" scheme="http://tonnyone.github.io/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://tonnyone.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>mongodb3.X 单机安装与配置</title>
    <link href="http://tonnyone.github.io/2018/05/05/mongodb_install/"/>
    <id>http://tonnyone.github.io/2018/05/05/mongodb_install/</id>
    <published>2018-05-05T02:40:12.000Z</published>
    <updated>2021-01-11T21:33:44.475Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/mongodb.jpg" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p><a href="https://www.mongodb.com/download-center?jmp=docs&amp;_ga=1.201102574.1776437196.1479373354#community" title="下载地址" target="_blank" rel="noopener">下载安装包</a></p><p>我用的是社区版通用64位安装包(至于直接解压安装,还是用包管理器安装看个人习惯,大多数人应该是解压安装方便管理)</p><a id="more"></a><h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><p>我的在了(/usr/local/mongodb)目录</p><h3 id="新建conf目录添加配置文件-mongo-conf"><a href="#新建conf目录添加配置文件-mongo-conf" class="headerlink" title="新建conf目录添加配置文件 mongo.conf"></a>新建conf目录添加配置文件 mongo.conf</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">  <span class="attr">verbosity:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">"/usr/local/mongodb/log/mongod.log"</span></span><br><span class="line">  <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">timeStampFormat:</span> <span class="string">iso8601-local</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">dbPath:</span> <span class="string">"/home/mongodb/data"</span></span><br><span class="line">  <span class="attr">engine:</span> <span class="string">wiredTiger</span></span><br><span class="line">  <span class="attr">wiredTiger:</span></span><br><span class="line">    <span class="attr">engineConfig:</span></span><br><span class="line">      <span class="attr">cacheSizeGB:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">journalCompressor:</span> <span class="string">snappy</span></span><br><span class="line">  <span class="attr">directoryPerDB:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">journal:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">processManagement:</span></span><br><span class="line">  <span class="attr">fork:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">authorization:</span> <span class="string">disabled</span></span><br><span class="line"><span class="attr">setParameter:</span></span><br><span class="line">  <span class="attr">enableLocalhostAuthBypass:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ul><li>此时配置里面项<code>authorization</code>是<code>disabled</code>的</li><li><code>cacheSizeGB</code> 为默认占用操作系统的内存<code>60%</code>或者最小1G</li></ul><h3 id="新建启动脚本-startmq-sh-如下"><a href="#新建启动脚本-startmq-sh-如下" class="headerlink" title="新建启动脚本 startmq.sh(如下:)"></a>新建启动脚本 startmq.sh(如下:)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f /sys/kernel/mm/transparent_hugepage/enabled; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f /sys/kernel/mm/transparent_hugepage/defrag; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> 0 | sudo tee /proc/sys/vm/zone_reclaim_mode</span><br><span class="line">numactl --interleave=all /home/eversec/mongodb/bin/mongod --config ../conf/mongod.conf</span><br></pre></td></tr></table></figure><ul><li>启动前: 禁用大内存页<a href="https://docs.mongodb.com/manual/tutorial/transparent-huge-pages/" title="官方详细解释" target="_blank" rel="noopener">官方详细解释</a></li><li>以numacl启动</li><li>启动成功添加管理用户</li></ul><h3 id="新建一个超级管理员-role为root"><a href="#新建一个超级管理员-role为root" class="headerlink" title="新建一个超级管理员 role为root"></a>新建一个超级管理员 role为root</h3><p><a href="https://docs.mongodb.com/v3.2/reference/built-in-roles/" title="mongodb内建角色" target="_blank" rel="noopener">mongodb内建角色</a><br><a href="https://docs.mongodb.com/manual/reference/method/db.grantRolesToUser/#db.grantRolesToUser" title="给用户赋权限" target="_blank" rel="noopener">给用户赋权限命令</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.createUser(&#123;</span><br><span class="line">  user:<span class="string">"root"</span>,</span><br><span class="line">  pwd:<span class="string">"123456"</span>,</span><br><span class="line">  roles:[&#123;</span><br><span class="line">      role:<span class="string">"root"</span>,</span><br><span class="line">      db:<span class="string">"admin"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="重启mongo并新建数据库"><a href="#重启mongo并新建数据库" class="headerlink" title="重启mongo并新建数据库"></a>重启mongo并新建数据库</h3><ol><li>我们用kill -2 杀掉进程</li></ol><p><strong>注意:</strong> 官方特意说明千万不要kill -9 损坏数据<br><a href="https://docs.mongodb.com/v3.4/tutorial/manage-mongodb-processes/" title="mongodb 进程说明" target="_blank" rel="noopener">mongodb 进程说明</a></p><ol><li>启动数据库</li></ol><ul><li>修改conf文件 mongo.conf 中配置项<code>authorization</code>为<code>enabled</code></li><li>执行刚才的启动脚本启动数据库</li><li>登录mongodb</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mongo 127.0.0.1:27017/<span class="built_in">test</span> --authenticationDatabase admin -uroot -p123456</span><br></pre></td></tr></table></figure><ul><li>(直接使用root 用户无需此步骤)新建数据库并为数据库单独添加读写用户</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use testDb</span><br><span class="line">db.createUser(&#123;</span><br><span class="line">  user:<span class="string">"test"</span>,</span><br><span class="line">  pwd:<span class="string">"test123456"</span>,</span><br><span class="line">  roles:[&#123;</span><br><span class="line">      role:<span class="string">"readWrite"</span>,</span><br><span class="line">      db:<span class="string">"testDb"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><a href="https://docs.mongodb.com/manual/reference/configuration-options/" title="mongodb配置文件" target="_blank" rel="noopener">mongodb配置项说明</a></p><h3 id="关于企业版和社区版"><a href="#关于企业版和社区版" class="headerlink" title="关于企业版和社区版"></a>关于企业版和社区版</h3><ol><li>官网给出的解释:</li></ol><ul><li><strong>In-memory Storage Engine</strong><blockquote><p>高吞吐量,低延迟</p></blockquote></li><li><strong>Encrypted Storage Engine</strong><blockquote><p>数据加密</p></blockquote></li><li><strong>Advanced Security</strong><blockquote><p>使用LDAP和Kerberos访问控制，全面的审计功能</p></blockquote></li><li>除了Ops Manager，Compass和BI连接器之外，还提供对MongoDB和最佳SLA的最全面的支持</li></ul><p><a href="http://stackoverflow.com/questions/26527603/mongodb-opensource-vs-mongodb-enterprise" title="stackoverflow" target="_blank" rel="noopener">stackoverflow关于社区版和企业版</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.mongodb.com/manual/administration/production-notes/" title="官网生产环境安装mongodb注意事项说明" target="_blank" rel="noopener">官网生产环境安装mongodb注意事项</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/mongodb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;h3 id=&quot;下载安装包&quot;&gt;&lt;a href=&quot;#下载安装包&quot; class=&quot;headerlink&quot; title=&quot;下载安装包&quot;&gt;&lt;/a&gt;下载安装包&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.mongodb.com/download-center?jmp=docs&amp;amp;_ga=1.201102574.1776437196.1479373354#community&quot; title=&quot;下载地址&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载安装包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我用的是社区版通用64位安装包(至于直接解压安装,还是用包管理器安装看个人习惯,大多数人应该是解压安装方便管理)&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://tonnyone.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mongodb" scheme="http://tonnyone.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>一文完全理解HTTPS</title>
    <link href="http://tonnyone.github.io/2018/04/15/https/"/>
    <id>http://tonnyone.github.io/2018/04/15/https/</id>
    <published>2018-04-14T18:00:00.000Z</published>
    <updated>2021-01-11T21:33:44.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/https/https.png" alt=""></p><h2 id="http通信有什么问题呢"><a href="#http通信有什么问题呢" class="headerlink" title="http通信有什么问题呢"></a>http通信有什么问题呢</h2><h3 id="1-可能被窃听"><a href="#1-可能被窃听" class="headerlink" title="1. 可能被窃听"></a>1. 可能被窃听</h3><ul><li>HTTP 本身不具备加密的功能,HTTP 报文使用明文方式发送</li><li>由于互联网是由联通世界各个地方的网络设施组成,所有发送和接收经过某些设备的数据都可能被截获或窥视。(例如大家都熟悉的抓包工具:Wireshark),即使经过加密处理,也会被窥视是通信内容,只是可能很难或者无法破解出报文的信息而已</li></ul><a id="more"></a><h3 id="2-认证问题"><a href="#2-认证问题" class="headerlink" title="2. 认证问题"></a>2. 认证问题</h3><ul><li>无法确认你发送到的服务器就是真正的目标服务器(可能服务器是伪装的)</li><li>无法确定返回的客户端是否是按照真实意图接收的客户端(可能是伪装的客户端)</li><li>无法确定正在通信的对方是否具备访问权限,Web 服务器上某些重要的信息，只想发给特定用户</li><li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。</li></ul><h3 id="3-可能被篡改"><a href="#3-可能被篡改" class="headerlink" title="3. 可能被篡改"></a>3. 可能被篡改</h3><p>请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击被称为中间人攻击（Man-in-the-Middle attack，MITM）。</p><h2 id="HTTPS如何解决上述三个问题"><a href="#HTTPS如何解决上述三个问题" class="headerlink" title="HTTPS如何解决上述三个问题"></a>HTTPS如何解决上述三个问题</h2><p>HTTPS 只是在通信接口部分用 TLS（Transport Layer Security）协议代替而已。<br><img src="/uploads/https/https1.png" alt=""></p><p>SSL 和 TLS 的区别:</p><blockquote><p>传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。IETF将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。以下就简称SSL</p></blockquote><p><strong>TLS是SSL的标准</strong>. <strong>HTTPS</strong> 就是 <strong>HTTP + SSL</strong><br><img src="/uploads/https/https_http.png" alt=""></p><h3 id="SSL-协议"><a href="#SSL-协议" class="headerlink" title="SSL 协议"></a>SSL 协议</h3><h4 id="SSL-协议的实现需要用到的几类算法"><a href="#SSL-协议的实现需要用到的几类算法" class="headerlink" title="SSL 协议的实现需要用到的几类算法"></a>SSL 协议的实现需要用到的几类算法</h4><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>常用的加密算法:<code>DES</code>、<code>AES</code> ,<code>RC2</code>,<code>RC4</code><br>优点：算法公开、计算量小、加密速度快、加密效率高。<br>缺点：交易双方都使用同样钥匙，安全性得不到保证。<br><img src="/uploads/https/https2.png" alt=""></p><h5 id="非对称加密技术"><a href="#非对称加密技术" class="headerlink" title="非对称加密技术"></a>非对称加密技术</h5><p>常用的非对称加密算法:<code>RSA</code>,<code>DSA</code>,<code>Diffie-Hellman</code><br>优点:安全性高<br>缺点:速度慢</p><p><img src="/uploads/https/https3.png" alt=""></p><h5 id="完整性验证算法"><a href="#完整性验证算法" class="headerlink" title="完整性验证算法"></a>完整性验证算法</h5><p>HASH算法：<code>MD5</code>，<code>SHA1</code>，<code>SHA256</code><br>用作校验消息的完整性<br><img src="/uploads/https/tls_ssl.png" alt=""></p><h4 id="SSL协议构成"><a href="#SSL协议构成" class="headerlink" title="SSL协议构成"></a>SSL协议构成</h4><ol><li>第一层是Record Protocol, 用于定义传输格式。</li><li>第二层Handshake Protocol,它建立在SSL记录协议之上,用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li></ol><p><img src="/uploads/https/ssl_layout.png" alt=""></p><blockquote><p>工作方式:</p><ul><li>客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，</li><li>然后采用协商密钥对信息进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证对称密钥的安全。</li></ul></blockquote><h3 id="SSL密钥协商的过程如下"><a href="#SSL密钥协商的过程如下" class="headerlink" title="SSL密钥协商的过程如下"></a>SSL密钥协商的过程如下</h3><p><a href="/uploads/https/https_ssl.svg">点击查看大图</a><br><img src="/uploads/https/https_ssl.svg" alt=""><br><a href="https://upload.wikimedia.org/wikipedia/commons/a/ae/SSL_handshake_with_two_way_authentication_with_certificates.svg" target="_blank" rel="noopener">来源</a></p><p>详细描述下流程,主要分为<strong>四大步骤</strong>(此处略繁琐,不关注细节的可以先略过):</p><h5 id="1-client-hello-过程"><a href="#1-client-hello-过程" class="headerlink" title="1. client_hello 过程"></a>1. client_hello 过程</h5><p>客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息，相关信息如下：</p><ul><li><strong>版本信息:</strong> 支持的最高TSL协议版本version，从低到高依次 SSLv2 SSLv3 TLSv1 TLSv1.1 TLSv1.2，当前基本不再使用低于 TLSv1 的版本 </li><li><strong>加密套件候选列表(cipher suite):</strong> 认证算法 Au (身份验证)、密钥交换算法 KeyExchange(密钥协商)、对称加密算法 Enc (信息加密)和信息摘要 Mac(完整性校验);</li><li><strong>压缩算法候选列表</strong>:支持的压缩算法 compression methods 列表，用于后续的信息压缩传输;</li><li><strong>随机数</strong>:随机数就是上图里的RNc,用于后续生成协商密钥;</li><li><strong>协商数据</strong>:支持协议与算法的相关参数以及其它辅助信息等，常见的 SNI 就属于扩展字段，后续单独讨论该字段作用。</li></ul><h5 id="2-server-hello-过程"><a href="#2-server-hello-过程" class="headerlink" title="2. server_hello 过程"></a>2. server_hello 过程</h5><ul><li>服务端返回协商的信息结果，包括选择使用的协议版本version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 RNs等，其中随机数用于后续的密钥协商;</li><li>服务器证书链,用于身份校验和密钥交换</li><li>通知客户端server-hello 结束,请求客户端的证书和密钥</li></ul><h5 id="3-证书校验，协商最后通信密钥"><a href="#3-证书校验，协商最后通信密钥" class="headerlink" title="3. 证书校验，协商最后通信密钥"></a>3. 证书校验，协商最后通信密钥</h5><p>a. 客户端验证服务端证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作，合法性验证包括如下：</p><ul><li>证书链的可信性 trusted certificate path</li><li>证书是否吊销 revocation</li><li>有效期 expiry date，证书是否在有效时间范围;</li><li>域名 domain，核查证书域名是否与当前的访问域名匹配，匹配规则后续分析;</li></ul><p>b. 客户端发送客户端证书,公钥服务端验证(过程同客户端验证)<br>c. 客户端hash所有之前的消息,发送hash值和摘要,用客户端的私钥加密发送给服务端,服务端用客户端的公钥解密,验证了服务端获取的客户端的公钥和算法是正确的<br>d. 客户端生成<code>pms</code>,用服务端的公钥加密加密后发送给服务端<br>e. 客户端和服务端同时计算出最终会话密钥(<code>MS</code>)</p><h5 id="4-验证协商密钥"><a href="#4-验证协商密钥" class="headerlink" title="4. 验证协商密钥"></a>4. 验证协商密钥</h5><p>a. Client发送<code>ChangeCipherSpec</code>，指示Server从现在开始发送的消息都是加密过的<br>b. Client发送Finishd，包含了前面所有握手消息的hash，可以让server验证握手过程是否被第三方篡改<br>c. 服务端发送<code>ChangeCipherSpec</code>，指示Client从现在开始发送的消息都是加密过的<br>d. Server发送Finishd，包含了前面所有握手消息的hash，可以让client验证握手过程是否被第三方篡改，并且证明自己是Certificate密钥的拥有者，即证明自己的身份</p><h3 id="HTTPS完整建立连接过程-如下图"><a href="#HTTPS完整建立连接过程-如下图" class="headerlink" title="HTTPS完整建立连接过程,如下图"></a>HTTPS完整建立连接过程,如下图</h3><ol><li>首先建立tcp 握手连接</li><li>进行ssl 协议的握手密钥交换(Handshake protocal)</li><li>然后通过共同约定的密钥开始通信</li></ol><p><img src="/uploads/https/https_protocal.png" alt=""></p><h3 id="上文说到的证书是个什么玩意儿"><a href="#上文说到的证书是个什么玩意儿" class="headerlink" title="上文说到的证书是个什么玩意儿"></a>上文说到的证书是个什么玩意儿</h3><p><img src="/uploads/https/zhengshu_brower.png" alt="浏览器证书"></p><p>证书的作用就是,我和服务端通信,我怎么知道这个服务端是我要真正通信的服务端呢. 打个不恰当的比方:</p><p> 你在某宝购物,到了结算页面,你消费了100万,输入银行卡账号和密码付款,但是当你付款结束以后,你发现账户少了100万,但是账户页面还是显示未付款,你去打某宝客服,客服说你被别人盗号了100万没支付到我某宝,注意：这里面存在两种可能性</p><ol><li>一个是有可能遭到了中间人攻击(用户名和密码被黑客截获)</li><li>某宝收了你的钱，假装不承认,(抵赖)</li></ol><p><img src="/uploads/https/https_gj.png" alt=""></p><h4 id="申请和发放证书流程如下："><a href="#申请和发放证书流程如下：" class="headerlink" title="申请和发放证书流程如下："></a>申请和发放证书流程如下：</h4><p><img src="/uploads/https/zhengshu.png" alt=""></p><ol><li><p>服务方 Server 向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;</p></li><li><p>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</p></li><li><p>如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名; 签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;</p></li><li><p>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</p></li><li><p>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法;</p></li><li><p>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</p></li></ol><h4 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h4><p><img src="/uploads/https/zhengshulian.png" alt=""></p><ol><li>服务器证书 server.pem 的签发者为中间证书机构 inter，inter 根据证书 inter.pem 验证 server.pem 确实为自己签发的有效证书</li><li>中间证书 inter.pem 的签发 CA 为 root，root 根据证书 root.pem 验证 inter.pem 为自己签发的合法证书;</li><li>客户端内置信任 CA 的 root.pem 证书，因此服务器证书 server.pem 的被信任。</li></ol><blockquote><p>服务器证书、中间证书与根证书在一起组合成一条合法的证书链，证书链的验证是自下而上的信任传递的过程。</p></blockquote><p>证书的详细了解,请详细了解<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD" target="_blank" rel="noopener">PKI体系</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.wosign.com/info/https_tls_ssl_http.htmj" target="_blank" rel="noopener">详解 HTTPS、TLS、SSL、HTTP区别和关系</a></li><li><a href="http://galaxylab.org/https%E9%82%A3%E4%BA%9B%E4%BA%8B/" target="_blank" rel="noopener">https 那些事儿</a></li><li><a href="https://zh.wikipedia.org/zh-cn/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">WIKI传输层安全性协议</a></li><li><a href="https://book.douban.com/subject/24737674/" target="_blank" rel="noopener">图解TCP/IP</a></li><li><a href="http://www.nsfocus.net/index.php?act=magazine&amp;do=view&amp;mid=841" target="_blank" rel="noopener">绿盟月刊SSL/TLS/WTLS原理</a></li><li><a href="http://tianyawy.farbox.com/post/http/how-tls-work" target="_blank" rel="noopener">how tls work</a></li><li><a href="https://segmentfault.com/a/1190000002554673" target="_blank" rel="noopener">SSL/TLS原理详解</a></li><li><a href="https://www.wosign.com/Basic/aboutPKI.htm" target="_blank" rel="noopener">PKI 基础知识</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/https/https.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;http通信有什么问题呢&quot;&gt;&lt;a href=&quot;#http通信有什么问题呢&quot; class=&quot;headerlink&quot; title=&quot;http通信有什么问题呢&quot;&gt;&lt;/a&gt;http通信有什么问题呢&lt;/h2&gt;&lt;h3 id=&quot;1-可能被窃听&quot;&gt;&lt;a href=&quot;#1-可能被窃听&quot; class=&quot;headerlink&quot; title=&quot;1. 可能被窃听&quot;&gt;&lt;/a&gt;1. 可能被窃听&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HTTP 本身不具备加密的功能,HTTP 报文使用明文方式发送&lt;/li&gt;
&lt;li&gt;由于互联网是由联通世界各个地方的网络设施组成,所有发送和接收经过某些设备的数据都可能被截获或窥视。(例如大家都熟悉的抓包工具:Wireshark),即使经过加密处理,也会被窥视是通信内容,只是可能很难或者无法破解出报文的信息而已&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="protocal" scheme="http://tonnyone.github.io/categories/protocal/"/>
    
    
      <category term="http" scheme="http://tonnyone.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>一起学nodejs(写一个基于TCP/IP终端聊天系统)</title>
    <link href="http://tonnyone.github.io/2018/03/12/nodejs/nodejs_learn_5/"/>
    <id>http://tonnyone.github.io/2018/03/12/nodejs/nodejs_learn_5/</id>
    <published>2018-03-12T00:40:12.000Z</published>
    <updated>2021-01-11T21:33:44.477Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/tcpip.gif" alt="test"><br><a href="https://github.com/tonnyone/nodejs_practise/tree/master/tcp-ip" target="_blank" rel="noopener">源码地址</a><br><a id="more"></a></p><h2 id="TCP-IP-协议回顾"><a href="#TCP-IP-协议回顾" class="headerlink" title="TCP/IP 协议回顾"></a>TCP/IP 协议回顾</h2><p><img src="/uploads/tcp-ip-process.png" alt="三次握手四次挥手"></p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>面向连接的传输协议</li></ul><blockquote><p>可以这么理解,面向连接的意思是先连接了才能通信,UDP是无连接的,两者的区别是前者是打电话,后者是发短信</p></blockquote><ul><li>有序的</li></ul><blockquote><p>TCP下层IP协议传输是基于数据包无序的,假设一条消息分为四部分的话，TCP先收到第一和第四部分，会等待第二第三部分</p></blockquote><ul><li>可靠的</li></ul><blockquote><p>当数据发送出去以后,发送方就会等待一个确认消息，如果过了指定事件未收到，发送方就会对数据进行重发</p></blockquote><ul><li>面向字节的</li></ul><blockquote><p>TCP对字符以及字节是完全不知道的.</p></blockquote><ul><li>流控制</li></ul><blockquote><p>如果发送发和接收方的速度不匹配，TCP有流控制的机制保证发送和接收方数据的传输的平衡</p></blockquote><ul><li>拥堵控制</li></ul><blockquote><p>TCP 会通过控制数据包的传输速率来保证数据包的延迟率和丢包率不会太高，以此确认服务的质量</p></blockquote><p>适用场景:</p><ul><li>文件传输</li><li>HTTP</li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>无连接</li><li>不可靠</li><li>不保证有序</li><li>不会重发</li><li>无流量控制</li><li>无拥堵控制</li></ul><p>适用场景:</p><ul><li>包总量较小的通信</li><li>视频音频等多媒体通信</li><li>限定于LAN等特定网络中的通信</li><li>广播多播通信</li></ul><h3 id="基于TCP-和-UDP-的应用协议"><a href="#基于TCP-和-UDP-的应用协议" class="headerlink" title="基于TCP 和 UDP 的应用协议"></a>基于TCP 和 UDP 的应用协议</h3><p><img src="/uploads/tcp_yingyong.png" alt=""></p><h2 id="nodejs-中-tcp-ip"><a href="#nodejs-中-tcp-ip" class="headerlink" title="nodejs 中 tcp/ip"></a>nodejs 中 tcp/ip</h2><p>Node HTTP 服务器是构建于NODE TCP服务器之上的 , 即 <a href="http://nodejs.cn/api/http.html" target="_blank" rel="noopener">http.Server</a>继承至 <a href="http://nodejs.cn/api/net.html" target="_blank" rel="noopener">net.Server</a> 模块</p><h3 id="server基本代码"><a href="#server基本代码" class="headerlink" title="server基本代码"></a>server基本代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HOST = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">var</span> PORT = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">sock</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'connected: '</span> + sock.remoteAddress + <span class="string">':'</span> + sock.remotePort);</span><br><span class="line"></span><br><span class="line">  sock.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'DATA '</span> + sock.remoteAddress + <span class="string">': '</span> + data);</span><br><span class="line">    <span class="comment">// sock.write('Hey client, You said "' + data + '"');</span></span><br><span class="line">    sock.pipe(process.stdout)</span><br><span class="line">    sock.end()</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  sock.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CLOSED: '</span> + sock.remoteAddress + <span class="string">' '</span> + sock.remotePort);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;).listen(PORT, HOST);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server listening on '</span> + HOST + <span class="string">':'</span> + PORT);</span><br></pre></td></tr></table></figure><h3 id="client-基础代码"><a href="#client-基础代码" class="headerlink" title="client 基础代码"></a>client 基础代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">"net"</span>);</span><br><span class="line">stdin = process.stdin;</span><br><span class="line">stdout = process.stdout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">var</span> PORT = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> net.Socket();</span><br><span class="line">client.connect(PORT, HOST, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'CONNECTED TO SERVER: '</span> + HOST + <span class="string">':'</span> + PORT);</span><br><span class="line">  stdout.write(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">  stdin.resume(); <span class="comment">// 等待输入</span></span><br><span class="line">  stdin.setEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">  stdin.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"quit"</span> == input.trim()) &#123;</span><br><span class="line">      client.destroy();</span><br><span class="line">      stdin.destroy();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      client.write(input);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"server: "</span> + data);</span><br><span class="line">  stdout.write(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection closed"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="server端维护所有的客户client的关键代码"><a href="#server端维护所有的客户client的关键代码" class="headerlink" title="server端维护所有的客户client的关键代码"></a>server端维护所有的客户client的关键代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userkey = conn.remoteAddress+<span class="string">':'</span>+conn.remotePort;</span><br><span class="line"> <span class="keyword">if</span>(!users[userkey])&#123;</span><br><span class="line">   users[userkey] = &#123;<span class="attr">name</span>: <span class="string">'匿名'</span>,<span class="attr">conn</span>:conn&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> userKey <span class="keyword">in</span> users ) &#123;</span><br><span class="line">   <span class="keyword">if</span> (users.hasOwnProperty(userKey))&#123;</span><br><span class="line">     <span class="keyword">const</span> user = users[userKey];</span><br><span class="line">     conn.write(<span class="string">'\033[92m '</span>+ user.name +<span class="string">': '</span>+user.conn.remoteAddress+<span class="string">':'</span>+user.conn.remotePort+<span class="string">'\033[39m \n'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码请点击"><a href="#完整代码请点击" class="headerlink" title="完整代码请点击"></a><a href="https://github.com/tonnyone/nodejs_practise/tree/master/tcp-ip" target="_blank" rel="noopener">完整代码请点击</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/tcpip.gif&quot; alt=&quot;test&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/tonnyone/nodejs_practise/tree/master/tcp-ip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://tonnyone.github.io/categories/js/"/>
    
    
      <category term="nodejs" scheme="http://tonnyone.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>一起学nodejs(Buffer)</title>
    <link href="http://tonnyone.github.io/2018/02/12/nodejs/nodejs_learn_3/"/>
    <id>http://tonnyone.github.io/2018/02/12/nodejs/nodejs_learn_3/</id>
    <published>2018-02-11T22:40:12.000Z</published>
    <updated>2021-01-11T21:33:44.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Buffer-对象"><a href="#Buffer-对象" class="headerlink" title="Buffer 对象"></a>Buffer 对象</h2><p>官网是这么说的:</p><blockquote><p>在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。<br>TypedArray 现已被添加进 ES6 中，Buffer 类以一种更优化、更适合 Node.js 用例的方式实现了 Uint8Array API。<br>Buffer 类的实例类似于<strong>整数数组</strong>，但 Buffer 的<strong>大小是固定</strong>的、且在 V8<strong>堆外分配物理内存</strong>。 Buffer 的大小在被创建时确定，且<strong>无法调整大小</strong>。</p></blockquote><a id="more"></a><p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块<strong>原始内存</strong>。</p><p>说明：</p><ol><li>在 <strong>Node.js v6</strong> 之前的版本中，Buffer 实例是通过 Buffer 构造函数创建的，它根据提供的参数返回不同的 Buffer</li><li>为了使 Buffer 实例的创建更可靠、更不容易出错，各种 new Buffer() 构造函数已被 废弃，并由 <strong>Buffer.from()</strong>、<strong>Buffer.alloc()</strong>、和 <strong>Buffer.allocUnsafe()</strong> 方法替代。</li></ol><p>这里说到了<a href="http://es6.ruanyifeng.com/#docs/arraybuffer" target="_blank" rel="noopener">ES6 TypeArray</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testType = Buffer.alloc(<span class="number">1</span>,<span class="number">255</span>);</span><br><span class="line"><span class="keyword">const</span> testType2 = Buffer.alloc(<span class="number">1</span>,<span class="number">256</span>);</span><br><span class="line"><span class="built_in">console</span>.log(testType)</span><br><span class="line"><span class="built_in">console</span>.log(testType2)</span><br><span class="line"><span class="comment">// &lt;Buffer ff&gt;</span></span><br><span class="line"><span class="comment">// &lt;Buffer 00&gt; ，用256 填充的时候溢出了</span></span><br><span class="line"><span class="comment">//说明Buffer使用的确实是不带符号整数`Uint8`视图类型的TypedArray</span></span><br></pre></td></tr></table></figure><h3 id="关于-UnSafe-官网的说明"><a href="#关于-UnSafe-官网的说明" class="headerlink" title="关于 UnSafe 官网的说明"></a>关于 UnSafe 官网的说明</h3><blockquote><p>当调用 Buffer.allocUnsafe() 和 Buffer.allocUnsafeSlow() 时，被分配的内存段是未初始化的（没有用 0 填充）。 虽然这样的设计使得内存的分配非常快，但已分配的内存段可能包含潜在的敏感旧数据。 使用通过 Buffer.allocUnsafe() 创建的没有被完全重写内存的 Buffer ，在 Buffer 内存可读的情况下，可能泄露它的旧数据。<br>Node.js 可以在一开始就使用 <strong>–zero-fill-buffers</strong> 命令行启动选项强制所有创建时自动用 0 填充。</p></blockquote><h3 id="类方法关键API"><a href="#类方法关键API" class="headerlink" title="类方法关键API"></a>类方法关键API</h3><h4 id="Buffer-alloc-方法"><a href="#Buffer-alloc-方法" class="headerlink" title="Buffer.alloc() 方法"></a>Buffer.alloc() 方法</h4><p>Buffer.alloc(size[, fill[, encoding]])</p><ul><li>size <code>integer</code> 新建的 Buffer 期望的长度</li><li>fill <code>string</code> | <code>Buffer</code> | <code>integer</code> 用来预填充新建的 Buffer 的值。 默认: 0</li><li>encoding <code>string</code> 如果 fill 是字符串，则该值是它的字符编码。 默认: ‘utf8’</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定,默认用0填充</span></span><br><span class="line"><span class="keyword">const</span> buf = Buffer.alloc(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 输出: &lt;Buffer 00 00 00 00 00&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个Buffer 用某个字符填充</span></span><br><span class="line"><span class="keyword">const</span> buf1 = Buffer.alloc(<span class="number">5</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// 输出: &lt;Buffer 61 61 61 61 61&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个Buffer 用另一个Buffer填充,默认只取填充buffer的第一个字节</span></span><br><span class="line"><span class="keyword">const</span> buf3 = Buffer.alloc(<span class="number">5</span>, Buffer.alloc(<span class="number">1</span>,<span class="number">255</span>));</span><br><span class="line"><span class="comment">// 输出 &lt;Buffer ff ff ff ff ff&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf3);</span><br><span class="line"><span class="comment">// 输入 5 </span></span><br><span class="line"><span class="built_in">console</span>.log(buf3.length);</span><br><span class="line"><span class="comment">// 输入 5 </span></span><br><span class="line"><span class="built_in">console</span>.log(Buffer.byteLength(buf3));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'Hello World' base64 后的字符串表示,第二个参数是编码后的字符串，</span></span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.alloc(<span class="number">11</span>, <span class="string">'aGVsbG8gd29ybGQ='</span>, <span class="string">'base64'</span>);</span><br><span class="line"><span class="comment">// 输出: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf2);</span><br></pre></td></tr></table></figure><h4 id="Buffer-from-string-encoding-与-Buffer-from-buffer"><a href="#Buffer-from-string-encoding-与-Buffer-from-buffer" class="headerlink" title="Buffer.from(string[, encoding] 与 Buffer.from(buffer)"></a>Buffer.from(string[, encoding] 与 Buffer.from(buffer)</h4><ul><li>string <code>string</code> 要编码的字符串</li><li>encoding <code>string</code> string 的字符编码。 默认: ‘utf8’</li><li>buffer <code>Buffer</code> 一个要拷贝数据的已存在的 Buffer</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从一个Buffer 拷贝一个Buffer</span></span><br><span class="line"><span class="keyword">const</span> bufFrom1 = Buffer.from(<span class="string">'buffer'</span>);</span><br><span class="line"><span class="keyword">const</span> bufFrom2 = Buffer.from(bufFrom1);</span><br><span class="line">bufFrom1[<span class="number">0</span>] = <span class="number">0x61</span>; <span class="comment">//'a'</span></span><br><span class="line"><span class="comment">// 输出: auffer</span></span><br><span class="line"><span class="built_in">console</span>.log(bufFrom1.toString());</span><br><span class="line"><span class="comment">// 输出: buffer</span></span><br><span class="line"><span class="built_in">console</span>.log(bufFrom2.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bufFrom3= Buffer.from(<span class="string">'this is a tést'</span>);</span><br><span class="line"><span class="comment">// 输出: this is a test</span></span><br><span class="line"><span class="built_in">console</span>.log(bufFrom3.toString());</span><br><span class="line"><span class="comment">// 输出: this is a tC)st</span></span><br><span class="line"><span class="built_in">console</span>.log(bufFrom3.toString(<span class="string">'ascii'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bufFrom4= Buffer.from(<span class="string">'aGVsbG8gd29ybGQ='</span>, <span class="string">'base64'</span>);</span><br><span class="line"><span class="comment">// 输出: Hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(bufFrom4.toString());</span><br></pre></td></tr></table></figure><h4 id="Buffer-allocUnsafe"><a href="#Buffer-allocUnsafe" class="headerlink" title="Buffer.allocUnsafe()"></a>Buffer.allocUnsafe()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'Node.js'</span>;</span><br><span class="line"><span class="keyword">const</span> bufUnsafe = Buffer.allocUnsafe(str.length);</span><br><span class="line"><span class="comment">// 输出: 不确定</span></span><br><span class="line"><span class="built_in">console</span>.log(bufUnsafe.toString(<span class="string">'ascii'</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">  bufUnsafe[i] = str.charCodeAt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Node.js</span></span><br><span class="line"><span class="built_in">console</span>.log(bufUnsafe.toString(<span class="string">'ascii'</span>));</span><br></pre></td></tr></table></figure><blockquote><p>注意，Buffer 模块会预分配一个大小为 Buffer.poolSize 的内部 Buffer 实例作为快速分配池， 用于使用 Buffer.allocUnsafe() 新创建的 Buffer 实例，<br>仅限于当 size 小于或等于 Buffer.poolSize 除以2后的最大整数值.<br>对这个预分配的内部内存池的使用，是调用 Buffer.alloc(size, fill) 和 Buffer.allocUnsafe(size).fill(fill) 的关键区别。 具体地说，Buffer.alloc(size, fill) 永远不会使用这个内部的 Buffer 池，但如果 size 小于或等于 Buffer.poolSize 的一半， Buffer.allocUnsafe(size).fill(fill) 会使用这个内部的 Buffer 池。</p></blockquote><p>实例池的大小默认为: 8192(8k),可以修改,值为Buffer类的一个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.poolSize = <span class="number">9</span>*<span class="number">1024</span>;</span><br></pre></td></tr></table></figure><h3 id="其他的类方法"><a href="#其他的类方法" class="headerlink" title="其他的类方法"></a>其他的类方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出: ½ + ¼ = ¾: 9 个字符, 12 个字节 */</span></span><br><span class="line"><span class="keyword">const</span> bufOther3 = <span class="string">'\u00bd + \u00bc = \u00be'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Buffer.byteLength(bufOther3));<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(Buffer.byteLength(bufOther3,<span class="string">'utf-8'</span>));<span class="comment">//11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bufTo = Buffer.concat([bufC1, bufC2, bufC3]); <span class="comment">//buffer拼接</span></span><br><span class="line"><span class="keyword">const</span> bufTo1 = Buffer.concat([bufC1, bufC2, bufC3], totalLength);</span><br><span class="line"><span class="keyword">const</span> bufTo2 = Buffer.concat([bufC1, bufC2, bufC3],<span class="number">41</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bufTo);</span><br><span class="line"><span class="built_in">console</span>.log(bufTo1);<span class="comment">//42</span></span><br><span class="line"><span class="built_in">console</span>.log(bufTo2);<span class="comment">//42</span></span><br><span class="line"><span class="comment">//&lt;Buffer 61 61 61 61 61 61 61 61 61 61 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br><span class="line"><span class="comment">//&lt;Buffer 61 61 61 61 61 61 61 61 61 61 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br><span class="line"><span class="comment">//&lt;Buffer 61 61 61 61 61 61 61 61 61 61 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li>buf.copy</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bufCopy = Buffer.allocUnsafe(<span class="number">26</span>);</span><br><span class="line"><span class="keyword">const</span> bufCopy2 = Buffer.allocUnsafe(<span class="number">26</span>).fill(<span class="string">'!'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 97 是 'a' 的十进制 ASCII 值</span></span><br><span class="line">  bufCopy[i] = i + <span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝目标，目标开始位，源buffer的开始位，源buffer的结束位</span></span><br><span class="line">bufCopy.copy(bufCopy2, <span class="number">8</span>, <span class="number">16</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// abcdefghijklmnopqrstuvwxy</span></span><br><span class="line"><span class="built_in">console</span>.log(bufCopy.toString(<span class="string">'ascii'</span>, <span class="number">0</span>, <span class="number">25</span>));</span><br><span class="line"><span class="comment">// 输出: !!!!!!!!qrst!!!!!!!!!!!!!</span></span><br><span class="line"><span class="built_in">console</span>.log(bufCopy2.toString(<span class="string">'ascii'</span>, <span class="number">0</span>, <span class="number">25</span>));</span><br></pre></td></tr></table></figure><ul><li>buf.entries() //创建并返回一个[index,byte] 迭代器</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.from(<span class="string">'buffer'</span>);</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">//   [0, 98]</span></span><br><span class="line"><span class="comment">//   [1, 117]</span></span><br><span class="line"><span class="comment">//   [2, 102]</span></span><br><span class="line"><span class="comment">//   [3, 102]</span></span><br><span class="line"><span class="comment">//   [4, 101]</span></span><br><span class="line"><span class="comment">//   [5, 114]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> pair <span class="keyword">of</span> buf.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>buf.keys() // 创建并返回一个包含 buf 键名（索引）的迭代器。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.from(<span class="string">'buffer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">//   0</span></span><br><span class="line"><span class="comment">//   1</span></span><br><span class="line"><span class="comment">//   2</span></span><br><span class="line"><span class="comment">//   3</span></span><br><span class="line"><span class="comment">//   4</span></span><br><span class="line"><span class="comment">//   5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> buf.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>buf.values()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf = Buffer.from(<span class="string">'buffer'</span>);</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">//   98</span></span><br><span class="line"><span class="comment">//   117</span></span><br><span class="line"><span class="comment">//   102</span></span><br><span class="line"><span class="comment">//   102</span></span><br><span class="line"><span class="comment">//   101</span></span><br><span class="line"><span class="comment">//   114</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> buf.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>buffer.transcode(source, fromEnc, toEnc)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="built_in">require</span>(<span class="string">'buffer'</span>);</span><br><span class="line"><span class="keyword">const</span> newBuf = buffer.transcode(Buffer.from(<span class="string">'€'</span>), <span class="string">'utf8'</span>, <span class="string">'ascii'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newBuf.toString(<span class="string">'ascii'</span>));</span><br><span class="line"><span class="comment">// 输出: '?'</span></span><br></pre></td></tr></table></figure><ul><li>buf.includes(value[, byteOffset][, encoding])</li><li>buf.indexOf(value[, byteOffset][, encoding])</li><li>buf.lastIndexOf(value[, byteOffset][, encoding])</li></ul><h3 id="Buffer-目前支持的字符编码包括："><a href="#Buffer-目前支持的字符编码包括：" class="headerlink" title="Buffer 目前支持的字符编码包括："></a>Buffer 目前支持的字符编码包括：</h3><p>ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。<br>utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。<br>utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。<br>ucs2 - utf16le 的别名。<br>base64 - Base64 编码。<br>latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。<br>binary - latin1 的别名。<br>hex - 将每个字节编码为两个十六进制字符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Buffer-对象&quot;&gt;&lt;a href=&quot;#Buffer-对象&quot; class=&quot;headerlink&quot; title=&quot;Buffer 对象&quot;&gt;&lt;/a&gt;Buffer 对象&lt;/h2&gt;&lt;p&gt;官网是这么说的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。&lt;br&gt;TypedArray 现已被添加进 ES6 中，Buffer 类以一种更优化、更适合 Node.js 用例的方式实现了 Uint8Array API。&lt;br&gt;Buffer 类的实例类似于&lt;strong&gt;整数数组&lt;/strong&gt;，但 Buffer 的&lt;strong&gt;大小是固定&lt;/strong&gt;的、且在 V8&lt;strong&gt;堆外分配物理内存&lt;/strong&gt;。 Buffer 的大小在被创建时确定，且&lt;strong&gt;无法调整大小&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="js" scheme="http://tonnyone.github.io/categories/js/"/>
    
    
      <category term="nodejs" scheme="http://tonnyone.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>一起学nodejs(微型文件系统实现)</title>
    <link href="http://tonnyone.github.io/2018/02/11/nodejs/nodejs_learn_2/"/>
    <id>http://tonnyone.github.io/2018/02/11/nodejs/nodejs_learn_2/</id>
    <published>2018-02-10T22:40:12.000Z</published>
    <updated>2021-01-11T21:33:44.476Z</updated>
    
    <content type="html"><![CDATA[<p>用nodejs实现一个命令行的文件系统查看工具。<br><img src="/uploads/test_filesystem.gif" alt=""><br><!-- ![](https://note.youdao.com/yws/public/resource/7fb2090db7599db51497656dacc314de/xmlnote/BB7325F9803144E5A9D938400F0C8ECC/1141) --></p><a id="more"></a><p>为了练习nodejs cli 以及 少量的文件操作api.<br>收获如下:</p><ol><li><p>命令行ansic color 的使用</p></li><li><p>fs , path 模块的了解</p></li><li><p>stdin, stdout 输入输出事件的了解</p></li></ol><p><a href="https://github.com/tonnyone/nodejs_practise/tree/master/file-explore" target="_blank" rel="noopener">代码地址</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line">stdin = process.stdin;</span><br><span class="line">stdout = process.stdout;</span><br><span class="line"></span><br><span class="line">readDir(process.cwd());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readDir</span>(<span class="params">dirPath</span>) </span>&#123;</span><br><span class="line">  fs.readdir(dirPath, <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"\033[32mcurrent: \033[34m "</span> + dirPath + <span class="string">" \033[39m"</span>);</span><br><span class="line">    <span class="keyword">var</span> stats = [];</span><br><span class="line">    <span class="keyword">if</span> (!files.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"   \033[31m No files to show! \033[39m \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">"\033[36m"</span> +</span><br><span class="line">        <span class="string">"Select which file or dictionary you want to see: \n"</span> +</span><br><span class="line">        <span class="string">" \033[39m \n"</span></span><br><span class="line">    );</span><br><span class="line">    file(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">file</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> filename = files[i];</span><br><span class="line">      fs.stat(path.join(dirPath, filename), <span class="function"><span class="keyword">function</span>(<span class="params">error, stat</span>) </span>&#123;</span><br><span class="line">        stats[i] = stat;</span><br><span class="line">        <span class="keyword">if</span> (stat.isDirectory()) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"           "</span> + i + <span class="string">" \033[32m"</span> + filename + <span class="string">"/\033[39m"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"           "</span> + i + <span class="string">" \033[36m"</span> + filename + <span class="string">"/\033[39m"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i == files.length) &#123;</span><br><span class="line">          read();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          file(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">""</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">"\033[36m"</span> +</span><br><span class="line">          <span class="string">'Enter your choice (number), or back to up file path:(example: "../") , or quit input ("quit").'</span> +</span><br><span class="line">        <span class="string">"\033[39m"</span></span><br><span class="line">      );</span><br><span class="line">      stdout.write(<span class="string">"\033[36m"</span> + <span class="string">"your choice is &gt;&gt; "</span> + <span class="string">"\033[39m"</span>);</span><br><span class="line">      stdin.resume(); <span class="comment">// 输入等待</span></span><br><span class="line">      stdin.setEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">      stdin.removeAllListeners(<span class="string">"data"</span>); <span class="comment">//移除所有的监听输入的事件再注册,不然会有两次事件</span></span><br><span class="line">      stdin.on(<span class="string">"data"</span>, enterCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">enterCallback</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"quit"</span> == i.trim()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"\033[31m"</span> + <span class="string">"Bye bye! "</span> + <span class="string">"\033[39m"</span>);</span><br><span class="line">        stdin.end();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(<span class="built_in">Number</span>(i.trim()))) &#123;</span><br><span class="line">          fs.access(</span><br><span class="line">            path.normalize(path.resolve(dirPath, i.trim())),</span><br><span class="line">            fs.constants.R_OK,</span><br><span class="line">            err =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">""</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(</span><br><span class="line">                  <span class="string">"\033[31m"</span> +</span><br><span class="line">                    <span class="string">"you can not access this path : "</span> +</span><br><span class="line">                    path.resolve(dirPath, i.trim()) +</span><br><span class="line">                    <span class="string">"\033[39m"</span></span><br><span class="line">                );</span><br><span class="line">                readDir(path.resolve(dirPath));</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                readDir(path.resolve(dirPath, i.trim()));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> oneFile = files[<span class="built_in">Number</span>(i.trim())];</span><br><span class="line">        <span class="keyword">if</span> (!oneFile) &#123;</span><br><span class="line">          stdout.write(<span class="string">"    \033[36m"</span> + <span class="string">"Enter your choice: "</span> + <span class="string">"\033[39m"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (stats[<span class="built_in">Number</span>(i.trim())].isDirectory()) &#123;</span><br><span class="line">            readDir(path.join(dirPath, oneFile));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fs.readFile(</span><br><span class="line">              path.resolve(dirPath, files[<span class="built_in">Number</span>(i)]),</span><br><span class="line">              <span class="string">"utf-8"</span>,</span><br><span class="line">              <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(<span class="string">""</span>, err);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"\033[32m"</span> + <span class="string">"file content is:"</span> + <span class="string">"\033[39m"</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">""</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"\033[42m"</span> + data + <span class="string">"\033[40m"</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">""</span>);</span><br><span class="line">                readDir(dirPath);</span><br><span class="line">              &#125;</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用nodejs实现一个命令行的文件系统查看工具。&lt;br&gt;&lt;img src=&quot;/uploads/test_filesystem.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;!-- ![](https://note.youdao.com/yws/public/resource/7fb2090db7599db51497656dacc314de/xmlnote/BB7325F9803144E5A9D938400F0C8ECC/1141) --&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://tonnyone.github.io/categories/js/"/>
    
    
      <category term="nodejs" scheme="http://tonnyone.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>一起学nodejs(基本概念)</title>
    <link href="http://tonnyone.github.io/2018/02/10/nodejs/nodejs_learn_1/"/>
    <id>http://tonnyone.github.io/2018/02/10/nodejs/nodejs_learn_1/</id>
    <published>2018-02-09T22:40:12.000Z</published>
    <updated>2021-01-11T21:33:44.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="http://nodejs.cn" target="_blank" rel="noopener">nodejs 中文网</a><br>2009 年Ryan Dahl 柏林宣布nodeJs 技术<br>优点: 基于事件轮询(event loop)的技术,构建于V8之上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server  = http.creatServe(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  res.writeHead(<span class="string">'200'</span>)</span><br><span class="line">  res.end(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>上面这段代码并不是一个玩具,相反,它是一个高性能的服务器.甚至在某些场景之下，比现在的Apach和nginx这样的服务器都性能优越.<br><a id="more"></a></p><h2 id="服务器端js和客户端js的区别"><a href="#服务器端js和客户端js的区别" class="headerlink" title="服务器端js和客户端js的区别"></a>服务器端js和客户端js的区别</h2><p>javascript 是根据ECMAScript语言标准来实现的, 由于Node使用的是Google的V8，更接近ECMAScript的标准<br>V8的一些特性是一些浏览器不支持的, IE就更不用说了.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm version</span><br></pre></td></tr></table></figure><p>查看nodejs 以及 V8的版本号</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>global 和 客户端js的window一样,它上面的所有对象都可以被全局访问,命令行输入node,然后敲global 可以全部看到如下<br>其中所有全局执行上下文都在<strong>process</strong>对象中,就向在浏览器中只有一个window对象,在nodejs中只有一个process对象。</p><p><strong>console</strong>,<strong>setTimeout</strong>,<strong>setImmediate</strong> 等都是一些非常重要的API.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">&#123; <span class="attr">console</span>: [Getter],</span><br><span class="line">  ...</span><br><span class="line">  global: [Circular],</span><br><span class="line">  process:</span><br><span class="line">    process&#123;</span><br><span class="line">      title: <span class="string">''</span>,</span><br><span class="line">      version: <span class="string">'8.9.1'</span>,</span><br><span class="line">      ...</span><br><span class="line">  node: <span class="string">'8.9.1'</span>,</span><br><span class="line">  v8: <span class="string">'6.1'</span>,</span><br><span class="line">  ...</span><br><span class="line">  clearImmediate: [<span class="built_in">Function</span>],</span><br><span class="line">  clearInterval: [<span class="built_in">Function</span>],</span><br><span class="line">  clearTimeout: [<span class="built_in">Function</span>],</span><br><span class="line">  setImmediate: &#123; [<span class="built_in">Function</span>: setImmediate] [<span class="built_in">Symbol</span>(util.promisify.custom)]: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">  setInterval: [<span class="built_in">Function</span>],</span><br><span class="line">  setTimeout: &#123; [<span class="built_in">Function</span>: setTimeout] [<span class="built_in">Symbol</span>(util.promisify.custom)]: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">  <span class="built_in">module</span>:</span><br><span class="line">    Module: &#123;</span><br><span class="line">      id: <span class="string">'&lt;repl&gt;'</span>,</span><br><span class="line">      exports: &#123;&#125;,</span><br><span class="line">      parent: <span class="literal">undefined</span>,</span><br><span class="line">      filename: <span class="literal">null</span>,</span><br><span class="line">      loaded: <span class="literal">false</span>,</span><br><span class="line">      children: [],</span><br><span class="line">      paths:</span><br><span class="line">    <span class="built_in">require</span>:</span><br><span class="line">      &#123; [<span class="built_in">Function</span>: <span class="built_in">require</span>]</span><br><span class="line">      resolve: &#123; [<span class="built_in">Function</span>: resolve] paths: [<span class="built_in">Function</span>: paths] &#125;,</span><br><span class="line">      main: <span class="literal">undefined</span>,</span><br><span class="line">      extensions: &#123; <span class="string">'.js'</span>: [<span class="built_in">Function</span>], <span class="string">'.json'</span>: [<span class="built_in">Function</span>], <span class="string">'.node'</span>: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">      cache: &#123;&#125; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="模块-amp-包管理"><a href="#模块-amp-包管理" class="headerlink" title="模块&amp;包管理"></a>模块&amp;包管理</h3><p>nodejs 采用<code>npm</code>作为包管理机制,类似java中的maven<br>主要是这三个核心全局对象的用法: require,module,和export<br><strong>绝对模块</strong>: 指Node通过其内部node_modules查找模块或者内置的例如fs这样的模块</p><p><code>require(&#39;color&#39;)</code> 指的是安装路径为 <code>./node_modules/colors</code> 的模块</p><p><strong>相对模块</strong>: 指的是相对于工作目录中的JavaScript文件,一般是自己写的模块。</p><p>module_a.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.name = <span class="string">'我是A模块'</span></span><br><span class="line">exports.changeByThis = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'A模块自己被自己的方法改变了this'</span>;</span><br><span class="line">&#125;</span><br><span class="line">exports.changeByExport = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">exports.name = <span class="string">'A模块自己被自己的方法改变了exports'</span>;</span><br></pre></td></tr></table></figure><p>module_b.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./module_a'</span>);</span><br><span class="line">exports.name=<span class="string">'我是b模块'</span>;</span><br><span class="line">exports.changeA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a.name = <span class="string">'b 模块改变了a模块'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module_test.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a  = <span class="built_in">require</span>(<span class="string">'./module_a'</span>)</span><br><span class="line"><span class="keyword">var</span> b  = <span class="built_in">require</span>(<span class="string">'./module_b'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aname:'</span>,a.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bname:'</span>,b.name)</span><br><span class="line">a.changeByThis()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aname:'</span>,a.name)</span><br><span class="line">a.changeByExport()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aname:'</span>,a.name)</span><br><span class="line">b.changeA()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aname:'</span>,a.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// aname: 我是A模块</span></span><br><span class="line"><span class="comment">// bname: 我是b模块</span></span><br><span class="line"><span class="comment">// this &#123;&#125;</span></span><br><span class="line"><span class="comment">// aname: A模块自己被自己的方法改变了this</span></span><br><span class="line"><span class="comment">// aname: A模块自己被自己的方法改变了exports</span></span><br><span class="line"><span class="comment">// aname: b 模块改变了a模</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong><br><a href="https://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="noopener">exports 和 module.exports 的区别</a></p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>浏览器端的js依赖DOM的api, 比如: <code>addEventListener</code>,<code>removeEventListener</code>,<code>dispathEvent</code></p><p>Nodejs 中事件的基础是EventEmitter对象,事件是Nodejs非阻塞异步事件驱动重要体现.</p><blockquote><p>所有能触发事件的对象都是 EventEmitter 类的实例。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数绑定到会被对象触发的命名事件上。 事件名称通常是驼峰式的字符串，但也可以使用任何有效的 JavaScript 属性名。<br>如: net.Server 对象会在每次有新连接时触发事件；fs.ReadStream 会在文件被打开时触发事件；流对象 会在数据可读时触发事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'触发了一个事件！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.once(<span class="string">'connection'</span>, () =&gt; &#123;<span class="comment">// 只会触发一次</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'首次调用！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line">myEmitter.emit(<span class="string">'connection'</span>);<span class="comment">// 只会触发一次</span></span><br><span class="line">myEmitter.emit(<span class="string">'connection'</span>);</span><br></pre></td></tr></table></figure><h2 id="阻塞和非阻塞IO"><a href="#阻塞和非阻塞IO" class="headerlink" title="阻塞和非阻塞IO"></a>阻塞和非阻塞IO</h2><p>所有关于Nodejs的讨论都使人们把关注点在了起高并发的能力上面,但是Node是如何给开发这提供一个构建高性能网络应用的能力的呢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'World'</span>)</span><br><span class="line">&#125;,<span class="number">5000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>)</span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// Bye</span></span><br><span class="line"><span class="comment">// World</span></span><br></pre></td></tr></table></figure><blockquote><p>采用事件轮询意味着什么呢? 从本质上说, Node 会显注册事件，随后不断的询问内核这些事件有没有分发，当事件分发时，对应的回调函数就会被触发。如果没有事件触发，则继续执行其他代码，直到有新事件的时候，再去执行的对应的回调函数</p></blockquote><p>其他语言的代码如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span>(<span class="string">'Hello'</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">print</span>(<span class="string">'World'</span>);</span><br></pre></td></tr></table></figure><p>sleep一旦执行，执行会被阻塞一段指定的时间，并且会在阻塞时间未到设定时间之前不做任何操作，所以sleep是同步的。而Nodejs 的setTimeout只是注册了一个事件,程序继续执行,所以这个是异步的。</p><blockquote><p>Nodejs 并发实现也采用了事件轮询。所有向http,net这样原生模块中IO部分都采用事件轮询技术。Node使用事件轮询会触发一个和文件描述符相关的通知。文件描述符是抽象的句柄，存在对打开文件，socket,管道等的引用。本质上来说，当Node接收道从浏览器发来的Http请求时，底层的TCP连接会分配一个文件描述符，队友如果客户端向服务器发送数据，Node会受到文件描述符的通知，去触发相应的回调函数.</p></blockquote><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now()-start);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line"><span class="comment">// 10436</span></span><br></pre></td></tr></table></figure><p>为什么会这样, 事件轮询被JavaScript代码阻塞了。由于回调函数需要执行很长一段事件. 所以下一个事件轮询执行的事件就远远超过了2s<br>关键在于，在V8调用堆栈非常快的情况下，同一时刻无需处理多个请求.而Nodejs不会因为有数据库访问或者硬盘访问而挂起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  database.getInformation(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当请求到达的时候,调用堆栈只有数据库调用。由于调用时非阻塞的。当数据库IO完成时。就完全取决于事件轮询合适在初始化新的调用堆栈。<br>当数据库响应时,内核会通知NodeJs事件轮询。Nodejs 现在可以继续处理其他事情了。</p><p>EventLoop 比较复杂,作为初学者就不敢在这里板门弄斧了,大家看之前两位大神的讨论:</p><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a><br><a href="http://blog.csdn.net/lin_credible/article/details/40143961" target="_blank" rel="noopener">【朴灵评注】JavaScript 运行机制详解：再谈Event Loop</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://nodejs.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nodejs 中文网&lt;/a&gt;&lt;br&gt;2009 年Ryan Dahl 柏林宣布nodeJs 技术&lt;br&gt;优点: 基于事件轮询(event loop)的技术,构建于V8之上&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; http = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;http&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; server  = http.creatServe(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;req,res&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.writeHead(&lt;span class=&quot;string&quot;&gt;&#39;200&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.end(&lt;span class=&quot;string&quot;&gt;&#39;Hello World&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server.listen(&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这段代码并不是一个玩具,相反,它是一个高性能的服务器.甚至在某些场景之下，比现在的Apach和nginx这样的服务器都性能优越.&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://tonnyone.github.io/categories/js/"/>
    
    
      <category term="nodejs" scheme="http://tonnyone.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>springboot 1.配置外置打包模板工程</title>
    <link href="http://tonnyone.github.io/2018/02/10/spring%20cloud/springboot%20modal/"/>
    <id>http://tonnyone.github.io/2018/02/10/spring cloud/springboot modal/</id>
    <published>2018-02-09T22:40:12.000Z</published>
    <updated>2021-01-11T21:33:44.477Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="springboot" scheme="http://tonnyone.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://tonnyone.github.io/tags/java/"/>
    
      <category term="spring" scheme="http://tonnyone.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>迟到的2017年终总结</title>
    <link href="http://tonnyone.github.io/2018/02/01/2017%20%E6%80%BB%E7%BB%93/"/>
    <id>http://tonnyone.github.io/2018/02/01/2017 总结/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2021-01-11T21:33:44.470Z</updated>
    
    <content type="html"><![CDATA[<p>2018年已经过去5天,时间就沙漏，无论你是否情愿总是一秒一秒的滴答。</p><p>17年没有做出什么为外人道的事情。</p><p>27岁的我已经不在，回望过去一年, 还是不能平静的思考,患得患失。</p><p>读的书有六七,理解确只有三四。</p><p>在技术的积累上总是找不到方向，整天像个着急的倒霉蛋，忙碌确无所得</p><p>很幸运的收获了了等待宝宝出生的喜悦，陪老婆产检是件幸福的事情。</p><p>期待2018 有些许所思所得吧。</p><p>跟着时间奔跑起来，但愿明年的总结不会写的这么单薄。</p><p>希望18年总结可以这么说</p><blockquote><p>岁月不饶人，我亦未曾饶过岁月。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年已经过去5天,时间就沙漏，无论你是否情愿总是一秒一秒的滴答。&lt;/p&gt;
&lt;p&gt;17年没有做出什么为外人道的事情。&lt;/p&gt;
&lt;p&gt;27岁的我已经不在，回望过去一年, 还是不能平静的思考,患得患失。&lt;/p&gt;
&lt;p&gt;读的书有六七,理解确只有三四。&lt;/p&gt;
&lt;p&gt;在技术的积
      
    
    </summary>
    
      <category term="随笔" scheme="http://tonnyone.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript 异步编程-5.异步脚本加载</title>
    <link href="http://tonnyone.github.io/2017/12/20/javascript/browser/"/>
    <id>http://tonnyone.github.io/2017/12/20/javascript/browser/</id>
    <published>2017-12-19T16:00:00.000Z</published>
    <updated>2021-01-11T21:33:44.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步脚本加载"><a href="#异步脚本加载" class="headerlink" title="异步脚本加载"></a>异步脚本加载</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = <span class="string">"allMyClientSideCode.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>放在哪儿? </p><ul><li>head标签里面</li></ul><p>用户在脚本加载完毕之前一直处于“白屏死机”状态</p><ul><li>放到body 后面</li></ul><a id="more"></a><p>原本应该进行客户端渲染的地方却散布着不起作用的控件和空空如也的方框。</p><p>完美解决问题的办法<br>完美解决这个问题需要对脚本分而治之：那些负责让页面更好看、更好用的脚本应该立即加载，而那些可以待会儿再加载的脚本稍后再加载。<br>HTML5之async/defer属性的作用，以及两个流行的脚本加载库：yepnope和Require.js。</p><h2 id="Script-标签再认识"><a href="#Script-标签再认识" class="headerlink" title="Script 标签再认识"></a>Script 标签再认识</h2><p>经典型和非阻塞型</p><h3 id="阻塞型脚本"><a href="#阻塞型脚本" class="headerlink" title="阻塞型脚本"></a>阻塞型脚本</h3><p>script 标签被称为阻塞型标签<br>现代浏览器看到阻塞型\<script\>标签时，会跳过阻塞点继续读取文档及下载其他资源（脚本和样式表）。但直到脚本下载完毕并运行之后，浏览器才会评估阻塞点之后的那些资源。</script\></p><p>因此，如果网页文档的\<head\>标签里有5个阻塞型\<script\>标签，则在所有这5个脚本均下载完毕并运行之前，用户除了页面标题之外看不到任何东西。不仅如此，即便这些脚本运行了，它们也只能看到阻塞点之前的那部分文档。如果想看到<body>标签中正等待加载的那些好东西，就必须给像document.onreadys-tatechange这样的事件绑定一个事件处理器。</body></script\></head\></p><p>基于上述原因，现在越来越流行把脚本放在页面\<body\>标签的尾部。这样，一方面用户可以更快地看到页面，另一方面脚本也可以主动亲密接触DOM而无需等待事件来触发自己。对大多数脚本而言，这次“搬家”是个巨大的进步。</body\></p><p>但并非所有脚本都一样。在向下搬动脚本之前，请先问自己3个问题。</p><ul><li>该脚本是否有可能被\<body\>标签里的内联JavaScript直接调用？</body\></li><li>该脚本是否支持老式浏览器识别HTML5元素？Modern-izr支持，也正因为这个原因，最佳实践项目的典范HTML5 Boilerplate直接在文档顶部包含了Modernizr。</li><li>该脚本是否会影响已渲染页面的外观？Typekit宿主字体就是一个例子。如果把Typekit脚本放在文档末尾，那么页面文本就会渲染两次，即读取文档时即刻渲染，脚本运行时再次渲染。</li></ul><h3 id="脚本延迟执行"><a href="#脚本延迟执行" class="headerlink" title="脚本延迟执行"></a>脚本延迟执行</h3><p>理想情况下，脚本的加载应该与文档的加载同时进行，并且不影响DOM的渲染。这样，一旦文档就绪就可以运行脚本，因为已经按照\<script\>标签的次序加载了相应脚本。</script\></p><p>如果大家已经读到这里了，那么一定会迫不及待地想写一个自定义Ajax脚本加载器以满足这样的需求！不过，大多数浏览器都支持一个更为简单的解决方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src = <span class="string">"deferredScript.js"</span>&gt;</span><br></pre></td></tr></table></figure><p>添加defer（延迟）属性相当于对浏览器说：“请马上开始加载这个脚本吧，但是，请等到文档就绪且所有此前具有defer属性的脚本都结束运行之后再运行它。”在文档\<head\>标签里放入延迟脚本，既能带来脚本置于\<body\>标签时的全部好处，又能让大文档的加载速度大幅提升！</body\></head\></p><p>有什么不足？并非所有浏览器都支持defer。，甚至最新版的Opera都忽略了这个属性。<a href="https://caniuse.com/#search=defer" target="_blank" rel="noopener">参见</a></p><p>如果想确保自己的延迟脚本能在文档加载后运行，就必须将所有延迟脚本的代码都封装在诸如jQuery之$(document).ready之类的结构中。这是值得的，因为差不多97%的访客都能享受到并行加载的好处，同时另外3%的访客仍然能使用功能完整的JavaScript。</p><p>使用defer属性把bodyScript.js换成deferredScript.js，于是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- metadata and stylesheets go here --&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"headScripts.js"</span>&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">scripts</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"deferredScripts.js"</span>&gt;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span>  <span class="comment">&lt;!-- content goes here --&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请记住deferredScripts的封装很重要，这样即使浏览器不支持defer，deferredScripts也会在文档就绪事件之后才运行。如果页面主体内容远远超过几千字节，那么付出这点代价是完全值得的。</p><h3 id="脚本的完全并行化"><a href="#脚本的完全并行化" class="headerlink" title="脚本的完全并行化"></a>脚本的完全并行化</h3><p>如果你是斤斤计较到毫秒级页面加载时间的完美主义者，那么defer也许就像是淡而无味的薄盐酱油。你可不想一直等到此前所有的defer脚本都运行结束，当然也肯定不想等到文档就绪之后才运行这些脚本，更别提为了照顾Opera还使用什么$(doc-ument).ready了。你就是想尽快加载并且尽快运行这些脚本。</p><p>这也正是现代浏览器提供了async（异步）属性的原因</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src = <span class="string">"speedyGonzales.js"</span>&gt;</span><br><span class="line">&lt;script <span class="keyword">async</span> src = <span class="string">"roadRunner.js"</span>&gt;</span><br></pre></td></tr></table></figure><p>如果说defer让我们想到一种静静等待文档加载的有序排队场景，那么async就会让我们想到混乱的无政府状态。前面给出的那两个脚本会以任意次序运行，而且只要JavaScript引擎可用就会立即运行，而不论文档就绪与否。因此，抛开对速度的渴求，我们有什么理由用async呢？</p><p>async不像defer那样得到广泛的支持，因此很少有用户会注意到性能的提升。同时，由于异步脚本会在任意时刻运行，它实在太容易引起海森堡蚁虫之灾了（脚本刚好结束加载时就会蚁虫四起）。</p><p>但是，对那些一心一意搞独立的脚本来说，async确实是一次不大但很重要的胜利。获取一个负责添加反馈小部件的第三方脚本，再获取一个负责添加技术支持聊天框的第三方脚本，怎么样？页面没有它们也运行得很好，而且也不在乎它们谁先运行谁后运行。因此，对这些第三方脚本使用async属性，相当于一分钱没花就提升了它们的运行速度.</p><p>“如果我对同一个脚本既用defer又用async，会怎么样呢？”答案是，在那些同时支持这两个属性的浏览器中，async会覆盖掉defer。由于defer有着更广泛的支持，而且具有async的主要优势（允许在下载脚本的同时进行DOM的渲染），因此我们建议尽量使用defer代替async。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- metadata and stylesheets go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"headScripts.js"</span>&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">scripts</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"deferredScripts.js"</span> <span class="attr">defer</span>&gt;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- content goes here --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"feedbackWidget.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"chatWidget.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="可编程的脚本加载"><a href="#可编程的脚本加载" class="headerlink" title="可编程的脚本加载"></a>可编程的脚本加载</h2><p>yepnope和Require.js。</p><h3 id="直接加载脚本"><a href="#直接加载脚本" class="headerlink" title="直接加载脚本"></a>直接加载脚本</h3><p>在浏览器API层面，有两种合理的方法来抓取并运行服务器脚本。</p><ul><li>生成Ajax 请求bing用eval函数响应处理 </li><li>向Dom 插入script标签</li></ul><p>后一种方法更好，因为浏览器会替我们操心生成HTTP请求这样的事。再者，eval也有一些实际问题：泄漏作用域，调试搞得一团糟，而且还可能降低性能。因此，要想加载名为feature.js的脚本，我们应该用类似下面这样的代码来插入\<script\>标签。</script\></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'/js/feature.js'</span>;</span><br><span class="line">head.appendChild(script);</span><br></pre></td></tr></table></figure><p>我们如何才能知道脚本何时加载结束呢？我们可以给脚本本身添加一些代码以触发事件，但如果要为每个待加载脚本都添加这样的代码，那也太闹心了。或者是另外一种情况，即我们不可能给第三方服务器上的脚本添加这样的代码。</p><p>HTML5规范定义了一个可以绑定回调的onload属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>不过，IE8及更老的版本并不支持onload，它们支持的是onreadystatechange。某些浏览器在插入\<script\>标签时还会出现一些“灵异事件”。而且，这里甚至还没谈到错误处理呢！为了避免所有这些令人头疼的问题，笔者在此强烈建议使用脚本加载库。</script\></p><h3 id="yepnope的条件加载"><a href="#yepnope的条件加载" class="headerlink" title="yepnope的条件加载"></a>yepnope的条件加载</h3><p><a href="http://yepnopejs.com/" target="_blank" rel="noopener">yepnope</a><br>yepnope是一个简单的、轻量级的脚本加载库（压缩后的精简版只有1.7KB），其设计目标就是真诚服务于最常见的动态脚本加载需求。yepnope可以独立使用，也可以作为Modernizr特性检测库的一部分。</p><p>yepnope最简单的用法是，加载脚本并对脚本完成运行这一事件返回一个回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yepnope(&#123;</span><br><span class="line">  load: <span class="string">'oompaLoompas.js'</span>,</span><br><span class="line">  callback: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Oompa-Loompas ready!'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面我们要用yepnope来并行加载多个脚本并按给定次序运行它们。举个例子，假设我们想加载Back-bone.js，而这个脚本又依赖于Underscore.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yepnope(&#123; <span class="attr">load</span>: [<span class="string">'underscore.js'</span>, <span class="string">'backbone.js'</span>],</span><br><span class="line">    complete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>请注意，这里使用了complete（完成）而不是callback（回调）。其差别在于，脚本加载列表中的每个资源均会运行call-back，而只有当所有脚本都加载完成后才会运行complete。</p><p><strong> 条件加载</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yepnope(&#123;</span><br><span class="line">    test: Modernizr.touch,</span><br><span class="line">    yep: [<span class="string">'touchStyles.css'</span>, <span class="string">'touchApplication.js'</span>],</span><br><span class="line">    nope: [<span class="string">'mouseStyles.css'</span>, <span class="string">'mouseApplication.js'</span>],</span><br><span class="line">    complete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>yepnope的标志性特征是条件加载。给定test参数，yepnope会根据该参数值是否为真而加载不同的资源。举个例子，假设已经使用了Modernizr库，则可以以一定的准确度判断用户是否在用触摸屏设备，从而据此相应地加载不同的样式表及脚本。</p><p>yepnope最常见的用法之一就是加载垫片脚本以弥补老式浏览器缺失的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yepnope(&#123;</span><br><span class="line">    test: <span class="built_in">window</span>.json,</span><br><span class="line">    nope: [<span class="string">'json2.js'</span>],</span><br><span class="line">    complete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>页面使用了yepnope之后应该变成下面这种漂亮的标记结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- metadata and stylesheets go here --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"headScripts.js"</span>&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">scripts</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"deferredScripts.js"</span> <span class="attr">defer</span>&gt;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- content goes here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Require-js-AMD的智能加载"><a href="#Require-js-AMD的智能加载" class="headerlink" title="Require.js/AMD的智能加载"></a>Require.js/AMD的智能加载</h3><p>开发人员想通过脚本加载器让混乱不堪的富脚本应用变得更规整有序一些，而Require.js就是这样一种选择。Require.js这个强大的工具包能够自动和AMD技术一起捋顺哪怕最复杂的脚本依赖图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'moment'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">moment</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(moment().format(<span class="string">'dddd'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>require函数接受一个由模块名称构成的数组，然后并行地加载所有这些脚本模块。与yepnope不同，Require.js不会保证按顺序运行目标脚本，只是保证它们的运行次序能满足各自的依赖性要求，但前提是这些脚本的定义遵守了AMD（AsynchronousModule Definition，异步模块定义）规范。</p><p>AMD规范的宗旨是替浏览器做CommonJS标准已经替服务器做过的那些事。（Node.js模块即基于CommonJS标准。）AMD推行一个由Require.js负责提供的名叫define的全局函数，该函数有3个参数：一个模块名称，一个模块依赖性列表，以及一个在那些依赖性模块加载结束时触发的回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'myApplication'</span> [<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'&lt;body&gt;'</span>).append(<span class="string">'&lt;p&gt;Hello, async world!&lt;/p&gt;'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意这里传递给回调的是jQuery对象$。实际上，define接受的这个回调参数一直对应着依赖性列表中的各个模块依赖项。大家也许奇怪：define怎样知道捕获jQuery对象呢？答案是jQuery自己的AMD定义通过其define回调返回了jQuery对象，借此声明“这是我的导出对象”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define( <span class="string">"jquery"</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> jQuery; &#125; );</span><br></pre></td></tr></table></figure><p>AMD的奥妙不止于此，但这是精华所在。如果应用的每个脚本都添加了AMD定义，则意味着我们只要调用require就能保证其回调不被调用，除非既满足了应用对脚本的直接依赖性，又满足了脚本的依赖性和脚本所依赖的那些脚本的依赖性，并且所有脚本均按最大的并行性进行加载，而运行次序也和依赖图一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;异步脚本加载&quot;&gt;&lt;a href=&quot;#异步脚本加载&quot; class=&quot;headerlink&quot; title=&quot;异步脚本加载&quot;&gt;&lt;/a&gt;异步脚本加载&lt;/h1&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src = &lt;span class=&quot;string&quot;&gt;&quot;allMyClientSideCode.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;放在哪儿? &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;head标签里面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户在脚本加载完毕之前一直处于“白屏死机”状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;放到body 后面&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript 异步编程读书笔记" scheme="http://tonnyone.github.io/categories/javascript-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript 异步编程-4.async.js工作流控制</title>
    <link href="http://tonnyone.github.io/2017/12/15/javascript/async.js/"/>
    <id>http://tonnyone.github.io/2017/12/15/javascript/async.js/</id>
    <published>2017-12-14T16:00:00.000Z</published>
    <updated>2021-01-11T21:33:44.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Async-工作流控制"><a href="#Async-工作流控制" class="headerlink" title="Async 工作流控制"></a>Async 工作流控制</h1><p>假设需要执行一组I/O操作（或者并行执行，或者串行执行），该怎么做呢？这个问题在Node中非常常见，以至于有了个专有名称：工作流控制（也称作控制工作流）。就像Underscore.js可以大幅度简化同步代码中的迭代一样，优秀的工作流控制库也可以消解异步代码中的套话。</p><p>目前最流行的工作流控制库当属Caolan McMahon开发的强大的<a href="https://github.com/caolan/async" target="_blank" rel="noopener">Async.js</a>。<br>事实上，在我写作本书的时候，Async.js是npm登记在案的请求第三多的库，它正与Un-derscore.js、Express这样的超级巨星一起共沐荣光。</p><a id="more"></a><h2 id="异步工作流的次序问题"><a href="#异步工作流的次序问题" class="headerlink" title="异步工作流的次序问题"></a>异步工作流的次序问题</h2><p>假设想先按字母顺序读取recipes（菜谱）目录中的所有文件，接着把读取出的这些内容连接成一个字符串并显示出来。使用同步方法很容易做到这一点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">process.chdir(<span class="string">'recipes'</span>);</span><br><span class="line"><span class="keyword">var</span> concatenation = <span class="string">''</span>;</span><br><span class="line">fs.readdirSync(<span class="string">'.'</span>).filter(<span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.statSync(filename).isFile();</span><br><span class="line">&#125;).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    concatenation += fs.readFileSync(filename, <span class="string">'utf8'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(concatenation);</span><br></pre></td></tr></table></figure><p>不过，所有这种I/O阻塞的效率都极其低下，尤其是当应用程序还能同时做点其他事情的时候。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concatenation += fs.readFileSync(filename, <span class="string">'utf8'</span>);</span><br></pre></td></tr></table></figure><p>换成异步代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(filename, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;  concatenation += contents;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>因为这么做根本无法保证按照做出readFile调用的次序来触发readFile调用的回调。<br>readFile仅仅负责告诉操作系统开始读取某个文件。<br>对操作系统而言，读取短文件通常比读取长文件更快一些。因此，菜谱内容添加到concatenation字符串的次序是不可预知的。</p><h2 id="异步的数据收集方法"><a href="#异步的数据收集方法" class="headerlink" title="异步的数据收集方法"></a>异步的数据收集方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); process.chdir(<span class="string">'recipes'</span>);</span><br><span class="line">concatenation = <span class="string">''</span>;</span><br><span class="line">fs.readdir(<span class="string">'.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, filenames</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">readFileAt</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> filename = filenames[i];</span><br><span class="line">        fs.stat(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">            <span class="keyword">if</span> (!stats.isFile()) <span class="keyword">return</span> readFileAt(i + <span class="number">1</span>);</span><br><span class="line">            fs.readFile(filename, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, text</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">                concatenation += text;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> === filenames.length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">console</span>.log(concatenation);</span><br><span class="line">                &#125;</span><br><span class="line">                readFileAt(i + <span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    readFileAt(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用递归解决这个问题，存在一下两个问题</p><ul><li>回调中抛出异常,异常无法追踪</li><li>错误处理的逻辑，重复书写三次</li></ul><h3 id="async-js-的函数式写法"><a href="#async-js-的函数式写法" class="headerlink" title="async.js 的函数式写法"></a>async.js 的函数式写法</h3><p>我们想把同步迭代器所使用的filter和forEach方法替换成相应的异步方法。Async.js给了我们两个选择</p><ul><li>async.filter和async.forEach，它们会并行处理给定的数组。</li><li>async.filterSeries和async.forEachSeries，它们会顺序处理给定的数组。</li></ul><p>并行运行这些异步操作应该会更快，那为什么还要使用序列式方法呢？原因有两个。</p><ul><li>前面提到的工作流次序不可预知的问题。我们确实可以先把结果存储成数组，然后再joining（联接）数组来解决这个问题，但这毕竟多了一个步骤。</li><li>Node及其他任何应用进程能够同时读取的文件数量有一个上限。如果超过这个上限，操作系统就会报错。如果能顺序读取文件，则无需担心这一限制。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">process.chdir(<span class="string">'recipes'</span>);</span><br><span class="line"><span class="keyword">var</span> concatenation = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> dirContents = fs.readdirSync(<span class="string">'.'</span>);</span><br><span class="line"><span class="keyword">async</span>.filter(dirContents, isFilename, <span class="function"><span class="keyword">function</span> (<span class="params">filenames</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">async</span>.forEachSeries(filenames, readAndConcat, onComplete);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFilename</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">    fs.stat(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        callback(stats.isFile());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAndConcat</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, fileContents</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">        concatenation += fileContents;</span><br><span class="line">        callback();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onComplete</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(concatenation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter和forEach并不是仅有的与标准函数式迭代方法相对应的Async.js工具函数。Async.js还提供了以下方法：</p><ul><li>reject/rejectSeries，与filter刚好相反；</li><li>map/mapSeries，1:1变换</li><li>reduce/reduceRight，值的逐步变换</li><li>detect/detectSeries，找到筛选器匹配的值</li><li>sortBy，产生一个有序副本</li><li>some，测试是否至少有一个值符合给定标准</li><li>every，测试是否所有值均符合给定标准。</li></ul><h3 id="Async-js的错误处理技术"><a href="#Async-js的错误处理技术" class="headerlink" title="　Async.js的错误处理技术"></a>　Async.js的错误处理技术</h3><p>初始版本的异步代码实现一共有3条throw语句。<br>到了Async.js版本只用了2条throw，不过所有错误仍然会被抛出。<br>Async.js是怎么做到的呢？为什么不能只用1条throw呢？</p><p>简单来说，Async.js遵守Node的约定。这意味着所有的I/O回调都形如callback(err, results…)，唯一的例外是结果为布尔型的回调。布尔型回调的写法就是callback(result)，所以上一代码示例中的isFilename迭代器需要自己亲自处理错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFilename</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  fs.stat(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    callback(stats.isFile());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要怪就怪Node的fs.exists首开这一先河吧！而这也意味着使用了Async.js数据收集方法（filter/filterSeries、reject/reject-Series、detect/detectSeries、some、every等）的迭代器均无法报告错误。</p><p>所以，如果callback(err)确实是在readAndConcat中被调用的，则这个err会传递给完工回调（即onComplete）。Async.js只负责保证onComplete只被调用一次，而不管是因首次出错而调用，还是因成功完成所有操作而调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onComplete</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(concatenation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node的错误处理约定对Async.js数据收集方法而言也许并不理想，但对于Async.js的6所有其他方法而言，<br>遵守这些约定可以让错误干净利落地从各个任务流向完工回调。下一节会看到更多这样的例子。</p><h2 id="Async-js的任务组织技术"><a href="#Async-js的任务组织技术" class="headerlink" title="Async.js的任务组织技术"></a>Async.js的任务组织技术</h2><p>Async.js的数据收集方法解决了一个异步函数如何运用于一个数据集的问题。但如果是一个函数集而不是一个数据集，又该怎么办呢？本节将探讨Async.js中一些可以派发异步函数并收集其结果的强大工具。</p><h3 id="异步函数序列的运行"><a href="#异步函数序列的运行" class="headerlink" title="异步函数序列的运行"></a>异步函数序列的运行</h3><p>假设我们希望某一组异步函数能依次运行。在不使用工具函数的情况下，可能会编写出类似这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funcs[<span class="number">0</span>](<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    funcs[<span class="number">1</span>](<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        funcs[<span class="number">2</span>](onComplete);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>async.series</li><li>async.waterfall</li></ul><p>这两个方法均接受一组函数(任务列表),并按照顺序运行。<br>二者给任务列表中的每个函数均传递一个Node风格的回调。</p><p>前者提供给各个任务的只有回调，而后者还会提供任务列表中前一任务的结果。（所谓“结果”，指的是各个任务传递给其回调的非错误的值。）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>); </span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="keyword">async</span>.series([<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        setTimeout(callback, <span class="number">100</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        setTimeout(callback, <span class="number">300</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        setTimeout(callback, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Completed in '</span> + (<span class="keyword">new</span> <span class="built_in">Date</span> - start) + <span class="string">'ms'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（将async.series替换为async.waterfall不会对这个例子造成任何影响，因为这里各个任务的回调在运行时均不带参数。）</p><p>因为任务列表中的各个任务会按顺序完成，所以会在600毫秒之后（实际上比600毫秒稍长一些）运行完工回调（即因完成整个工作流事件而调用的回调，又称完工事件处理器）。Async.js传递给任务列表中每个函数的回调好像在说：“出错了吗（回调的首参数是否为错误）？如果没出错，我就要收集结果（回调的次参数）并运行下一个任务了。</p><h3 id="异步函数的并行运行"><a href="#异步函数的并行运行" class="headerlink" title="异步函数的并行运行"></a>异步函数的并行运行</h3><p>Async.js提供了async.series的并行版本，即async.paral-lel。就像async.series一样，async.parallel也接受一组形为function(callback) {…}的函数作为参数，但会再加上一个（可选的）在触发最末回调后运行的完工事件处理器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>); </span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="keyword">async</span>.parallel([<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    setTimeout(callback, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    setTimeout(callback, <span class="number">300</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    setTimeout(callback, <span class="number">200</span>);</span><br><span class="line">&#125;], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Completed in '</span> + (<span class="keyword">new</span> <span class="built_in">Date</span> - start) + <span class="string">'ms'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> async.series完成工作流需要用掉3次延时的总和（约600毫秒），而async.parallel的用时只是最长的那次延时（约300毫秒）。更为便利的是，<strong>Async.js按照任务列表的次序向完工事件处理器传递结果，而不是按照生成这些结果的次序</strong>。这样，我们既<br>拥有了并行机制的性能优势，又没有失去结果的可预知性。</p><h2 id="异步的工作流排队技术"><a href="#异步的工作流排队技术" class="headerlink" title="异步的工作流排队技术"></a>异步的工作流排队技术</h2><p>大多数情况下，前两节介绍的那些简单方法足以解决我们的异步窘境，但async.series和async.parallel均存在各自的局限性。</p><ul><li>任务列表是静态的。一旦调用了async.series或async.par-allel，就再也不能增减任务了。   </li><li>不可能问：“已经完成多少任务了？”任务处于黑箱状态，除非我们自行从任务内部派发更新信息。</li><li>只有两个选择，要么是完全没有并发性，要么是不受限制的并发性。这对文件I/O任务可是个大问题。如果要操作上千个文件，当然不想因按顺序操作而效率低下，但如果试着并行执行所有操作，又很可能会激怒操作系统。</li></ul><p>Async.js提供了一种可以解决上述所有问题的全能方法：<strong>async.queue</strong>:</p><p>async.queue的底层基本理念令人想起DMV（DynamicManagement View，动态管理视图）。它可以同时应对很多人（最多时等于在岗办事员的数目），但并不是每位办事员前面各排一个队，而是维持着一个排号队列。人到了就排队，并取得一个排队号码。任何一个办事员空闲时，就会叫下一个排队号码。</p><p>async.queue的接口比async.series和async.parallel稍微复杂一些。async.queue接受的参数有两个：一个是worker（办事员）函数，而不是一个函数列表；一个是代表着concurrency（并发度）的值，代表了办事员最多可同时处理的任务数。async.queue的返回值是一个队列，我们可以向这个队列推入任意的任务数据及可选的回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> concurrency = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> queue = <span class="keyword">async</span>.queue(worker, concurrency);</span><br><span class="line">queue.push(<span class="number">1</span>)</span><br><span class="line">queue.push(<span class="number">2</span>)</span><br><span class="line">queue.push(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>不过内在还是有点小区别：并发度为2时，需要两轮才能遍历事件队列；如果并发度为1，则需要3轮才能遍历，每轮输出一行代码；如果并发度为3或更大的值，则只需要1轮即可遍历。并发度为0的队列不会做任何事情。如果想要最大的并发度，请直接使用Infinity关键字。</p><h3 id="任务的入列"><a href="#任务的入列" class="headerlink" title="任务的入列"></a>任务的入列</h3><p>虽然queue.push与[].push同名，但二者存在两个很关键的差别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.push([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line">queue.push(<span class="number">2</span>);</span><br><span class="line">queue.push(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>这意味着不能直接使用数组作为任务的数据。不过可以使用其他任何东西（甚至函数）作为任务的数据。事实上，如果想让async.queue像async.series/async.parallel那样也使用一组函数作为任务列表，只需定义一个其次参数会直接传递给其首参数的worker函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">task, callback</span>) </span>&#123; </span><br><span class="line">  task(callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> concurrency = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> queue = <span class="keyword">async</span>.queue(worker, concurrency);</span><br><span class="line">queue.push(tasks);</span><br></pre></td></tr></table></figure><p>第二个差别。async.queue中的每次push调用可附带提供一个回调函数。如果提供了，该回调函数会直接送给worker函数作为其回调参数。因此，（假设worker函数确实运行了其回调，即它未因抛出错误而直接关停）下面这个例子将会触发3次输出事件，即输出3次’Task complete!’。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.push([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;            <span class="built_in">console</span>.log(<span class="string">'Task complete!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对async.queue而言，push方法的回调函数非常重要，因为async.queue不像async.series/async.parallel那样可以在内部存储每次任务的结果。如果想要这些结果，就必须自行去捕获。</p><h3 id="完工事件的处理"><a href="#完工事件的处理" class="headerlink" title="完工事件的处理"></a>完工事件的处理</h3><p>和async.series及其类似方法一样，我们也可以给async.queue指定一个完工事件处理器。不过，这时并不是传递完工事件处理器作为async.queue方法的参数，而是要附加它作为async.queue对象的drain（排空）属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">    setTimeout(callback, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> concurrency = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> queue = <span class="keyword">async</span>.queue(worker, concurrency);</span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">queue.drain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Completed in '</span> + (<span class="keyword">new</span> <span class="built_in">Date</span> - start) + <span class="string">'ms'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">queue.push([<span class="number">100</span>, <span class="number">300</span>, <span class="number">200</span>]);</span><br></pre></td></tr></table></figure><p>回想一下：async.series完成工作流需要大约600毫秒的时间（3次延时的总和），而async.parallel只用掉约300毫秒,。这里的并发度为2，所以工作流一开始就会并行运行前两次延时。不过结束运行那次100毫秒的延时之后，队列里的下一个任务（即200毫秒的延时）将会立即开始运行。因此，在这种情况下，async.queue和async.parallel差不多在同一时刻结束运行。这里工作流的次序起到了关键作用：如果第3次入列的是那个300毫秒的延时任务，则整个队列需用时约400毫秒才能完成。</p><p>遗憾的是，这意味着async.queue不能像async.waterfall那样提供清晰排序的结果。如果想收集那些入列的任务的结果数据，就只能靠自己了。</p><h3 id="队列的高级回调方法"><a href="#队列的高级回调方法" class="headerlink" title="队列的高级回调方法"></a>队列的高级回调方法</h3><p>尽管drain常常是我们唯一要用到的事件处理器，但async.queue还是提供了其他一些事件及其处理器。</p><ul><li>队末任务开始运行时，会调用队列的empty方法。（队末任务运行结束时，会调用队列的drain方法。）</li><li>达到并发度的上限时，会调用队列的saturated方法。</li><li>如果提供了一个函数作为push方法的次参数，则在结束运行给定任务时会调用该函数，或在给定任务列表中的每个任务结束运行时均调用一次该函数。</li></ul><h2 id="极简主义者Step-工作流控制"><a href="#极简主义者Step-工作流控制" class="headerlink" title="极简主义者Step 工作流控制"></a>极简主义者Step 工作流控制</h2><p><a href="https://github.com/creationix/step" target="_blank" rel="noopener">Step</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Async-工作流控制&quot;&gt;&lt;a href=&quot;#Async-工作流控制&quot; class=&quot;headerlink&quot; title=&quot;Async 工作流控制&quot;&gt;&lt;/a&gt;Async 工作流控制&lt;/h1&gt;&lt;p&gt;假设需要执行一组I/O操作（或者并行执行，或者串行执行），该怎么做呢？这个问题在Node中非常常见，以至于有了个专有名称：工作流控制（也称作控制工作流）。就像Underscore.js可以大幅度简化同步代码中的迭代一样，优秀的工作流控制库也可以消解异步代码中的套话。&lt;/p&gt;
&lt;p&gt;目前最流行的工作流控制库当属Caolan McMahon开发的强大的&lt;a href=&quot;https://github.com/caolan/async&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Async.js&lt;/a&gt;。&lt;br&gt;事实上，在我写作本书的时候，Async.js是npm登记在案的请求第三多的库，它正与Un-derscore.js、Express这样的超级巨星一起共沐荣光。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript 异步编程读书笔记" scheme="http://tonnyone.github.io/categories/javascript-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript 异步编程-3.Promise对象和Deferred对象</title>
    <link href="http://tonnyone.github.io/2017/12/10/javascript/promise/"/>
    <id>http://tonnyone.github.io/2017/12/10/javascript/promise/</id>
    <published>2017-12-09T16:00:00.000Z</published>
    <updated>2021-01-11T21:33:44.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise-对象和-Deferred-对象"><a href="#Promise-对象和-Deferred-对象" class="headerlink" title="Promise 对象和 Deferred 对象"></a>Promise 对象和 Deferred 对象</h1><p>Promise对象的最大优势仍然在于，它可以轻松从现有Promise对象派生出新的Promise对象。我们可以要求代表着并行任务的两个Promise对象合并成一个Promise对象，由后者负责通知前面那些任务都已完成。也可以要求代表着任务系列中首任务的Promise对象派生出一个能代表任务系列中末任务的Promise对象，这样后者就能知道这一系列任务是否均已完成。待会儿我们就会看到，Promise对象天生就适合用来进行这些操作。</p><h2 id="Promise极简史"><a href="#Promise极简史" class="headerlink" title="Promise极简史"></a>Promise极简史</h2><ul><li>2007 Dojo框架刚从Twisted框架汲取灵感，新增了一个叫做dojo.Deferred的对象。</li><li>2009 Kris Zyp有感于dojo.Deferred的影响力提出了CommonJS之Promises/A规范</li><li>同年，Node.js首次亮相。Node早期的几个版本在其非阻塞式API中用到了Promise。</li><li>2010 Ryan Dahl决定切换至当时为人所熟知的callback(err, result…)格式，因为Promise是一种属于“用户之境”的甚高层构造。</li><li>2011 jQuery 1.5在2011年1月携$.ajax重量级重写之势，用其Promise实现震惊了无数初次接触Promise对象的开发者。不过，其他的开发者则忧心忡忡，因为jQuery 1.5对Promises/A规范的无视导致了微妙的API差异。</li></ul><a id="more"></a><h2 id="生成Promise对象"><a href="#生成Promise对象" class="headerlink" title="生成Promise对象"></a>生成Promise对象</h2><p>假设我们提示用户应敲击Y键或N键。为此要做的第一件事就是生成一个$.Deferred实例以代表用户做出的决定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promptDeferred = <span class="keyword">new</span> $.Deferred();</span><br><span class="line">promptDeferred.always(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'A choice was made:'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promptDeferred.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Starting game...'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promptDeferred.fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'No game today.'</span>);</span><br><span class="line">&#125;);（</span><br><span class="line"><span class="comment">//注： always关键字仅适用于jQuery 1.6 + 。）</span></span><br></pre></td></tr></table></figure><p>大家可能会奇怪：为什么本节叫做“生成Promise对象”，却要生成一个Deferred（延迟）实例？别担心，Deferred就是Promise！更准确地说，Deferred是Promise的超集，它比Promise多了一项关键特性：可以直接触发。纯Promise实例只允许添加多个调用，而且必须由其他什么东西来触发这些调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#playGame'</span>).focus().on(<span class="string">'keypress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Y = <span class="number">121</span>,</span><br><span class="line">        N = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">if</span> (e.keyCode === Y) &#123;</span><br><span class="line">        promptDeferred.resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.keyCode === N) &#123;</span><br><span class="line">        promptDeferred.reject();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="http://jsfiddle.net/TrevorBurnham/PJ6Bf/" target="_blank" rel="noopener">例子</a></p><p>Promise只能执行或拒绝一次，之后就失效了。我们断言，Promise对象会一直保持挂起状态，<br>直到被执行或拒绝。对Promise对象调用state（状态）方法，可以查看其状态是”pending”、”resolved”，还是”rejected”。（到jQuery 1.7才添加了state方法，此前的版本使用的是isResolved和isRe-jected。）<br>如果正在进行的一次性异步操作的结果可以笼统地分成两种（如成功/失败，或接受/拒绝），则生成Deferred对象就能直观地表达这次任务。</p><h3 id="生成纯的promise对象"><a href="#生成纯的promise对象" class="headerlink" title="生成纯的promise对象"></a>生成纯的promise对象</h3><p>我们刚刚了解到Deferred对象也是Promise对象，那么，如何得到一个不是Deferred对象的Promise对象呢？很简单，对Deferred对象调用promise方法即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promptPromise = promptDeferred.promise();</span><br></pre></td></tr></table></figure><p>promptPromise只是promptDeferred对象的一个没有re-solve/reject方法的副本。我们把回调绑定至Deferred或其下辖的Promise并无不同，因为这两个对象本质上分享着同样的回调。它们也分享着同样的state（返回的状态值为”pending”、”re-solved”或”rejected”）。这意味着，对同一个Deferred对象生成多个Promise对象是毫无意义的。事实上，jQuery给出的只不过是同一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = promptDeferred.promise();</span><br><span class="line"><span class="keyword">var</span> promise2 = promptDeferred.promise();</span><br><span class="line"><span class="built_in">console</span>.log(promise1 === promise2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>每个Deferred对象都含有一个Promise对象，而每个Promise对象都代表着一个Deferred对象。有了De-ferred对象，就可以控制其状态，而有了纯Promise对象，只能读取其状态及附加回调。</p><h3 id="jQuery-API中的Promise对象"><a href="#jQuery-API中的Promise对象" class="headerlink" title="jQuery API中的Promise对象"></a>jQuery API中的Promise对象</h3><p>开头列举了jQuery的Ajax函数（$.ajax、$.get及$.post）可返回的几个Promise对象。<br>Ajax是演示Promise的绝佳用例：每次对远程服务器的调用都或成功或失败，而我们希望以不同的方式来处理这两种情况。不过，Promise也同样适用于本地的一些异步操作，譬如动画。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.error'</span>).fadeIn(afterErrorShown);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errorPromise = $(<span class="string">'.error'</span>).fadeIn().promise();</span><br><span class="line">errorPromise.done(afterErrorShown);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $flash = $(<span class="string">'.flash'</span>);</span><br><span class="line"><span class="keyword">var</span> showPromise = $flash.show().promise();</span><br><span class="line"><span class="keyword">var</span> hidePromise = $flash.hide().promise();</span><br></pre></td></tr></table></figure><p>相当简单，对不对？在jQuery 1.6及jQuery 1.7中，jQuery对象的promise方法只是一种权宜之计。如果使用Deferred对象的resolve方法作为动画的回调，即可自行轻松生成一个行为完全相同的动画版Promise对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slideUpDeferred = <span class="keyword">new</span> $.Deferred();</span><br><span class="line">$(<span class="string">'.menu'</span>).slideUp(slideUpDeferred.resolve);</span><br><span class="line"><span class="keyword">var</span> slideUpPromise = slideUpDeferred.promise();</span><br></pre></td></tr></table></figure><p>jQuery 1.8又向jQuery大家庭中新添了一种Promise资源：$.ready. promise()也能生成一个Promise对象，<br>并且当文档就绪时即执行该对象。这意味着以下3行代码现在是等效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(onReady); </span><br><span class="line">$(<span class="built_in">document</span>).ready(onReady); </span><br><span class="line">$.ready.promise().done(onReady);</span><br></pre></td></tr></table></figure><h2 id="向回调传递数据"><a href="#向回调传递数据" class="headerlink" title="向回调传递数据"></a>向回调传递数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aDreamDeferred = <span class="keyword">new</span> $.Deferred();</span><br><span class="line">aDreamDeferred.done(<span class="function"><span class="keyword">function</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I had the most wonderful dream about'</span>, subject);</span><br><span class="line">&#125;);</span><br><span class="line">aDreamDeferred.resolve(<span class="string">'the JS event model'</span>);</span><br></pre></td></tr></table></figure><p>执行或拒绝Deferred对象时，提供的任何参数都会转发至相应的回调。<br>还有一些特殊的方法能实现在特定上下文中运行回调（即将this设置为特定的值）：resolveWith和rejectWith。<br>此时只需传递上下文环境作为第一个参数，同时以数组的形式传递所有其他</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slashdotter = &#123;</span><br><span class="line">    comment: <span class="function"><span class="keyword">function</span> (<span class="params">editor</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Obviously'</span>, editor, <span class="string">'is the best text editor.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> grammarDeferred = <span class="keyword">new</span> $.Deferred();</span><br><span class="line">grammarDeferred.done(<span class="function"><span class="keyword">function</span> (<span class="params">verb, object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[verb](object);</span><br><span class="line">&#125;);</span><br><span class="line">grammarDeferred.resolveWith(slashdotter, [<span class="string">'comment'</span>, <span class="string">'Emacs'</span>]);</span><br></pre></td></tr></table></figure><p>然而，将参数打包成数组是很痛苦的。所以还有一个小窍门：不再使用resolveWith/rejectWith，而是直接在目标上下文中调用resolve/ reject方法，这是因为resolve/reject可以直接将其上下文环境传递至自己所触发的回调。因此，对于前面那个例子，使用以下代码亦可得到同样的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grammarDeferred.resolve.call(slashdotter, <span class="string">'comment'</span>, <span class="string">'Emacs'</span>);</span><br></pre></td></tr></table></figure><h3 id="进度通知"><a href="#进度通知" class="headerlink" title="进度通知"></a>进度通知</h3><p>jQuery团队意识到了进度的重要并遵守Promises/A规范，<br>于是在jQuery 1.7中为Promise对象新添了一种可以调用无数次的回调。<br>这个回调叫做progress（进度）。举个例子，假设有人正在奋力达成美国全国小说写作月（National Novel WritingMonth，简写为NaNoWriMo）项目设定的日均码字目标，而我们希望更新一个指示器以反映他距离实现这个目标还有多远。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nanowrimoing = $.Deferred();</span><br><span class="line"><span class="keyword">var</span> wordGoal = <span class="number">5000</span>;</span><br><span class="line">nanowrimoing.progress(<span class="function"><span class="keyword">function</span> (<span class="params">wordCount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> percentComplete = <span class="built_in">Math</span>.floor(wordCount / wordGoal * <span class="number">100</span>);</span><br><span class="line">    $(<span class="string">'#indicator'</span>).text(percentComplete + <span class="string">'% complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">nanowrimoing.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#indicator'</span>).text(<span class="string">'Good job!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#document'</span>).on(<span class="string">'keypress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wordCount = $(<span class="keyword">this</span>).val().split(<span class="regexp">/\s+/</span>).length;</span><br><span class="line">    <span class="keyword">if</span> (wordCount &gt;= wordGoal) &#123;</span><br><span class="line">        nanowrimoing.resolve();</span><br><span class="line">    &#125;;</span><br><span class="line">    nanowrimoing.notify(wordCount);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Deferred对象的notify（通知）调用会调用我们设定的progress回调。就像resolve和reject一样，notify也能接受任意参数。<br>请注意，一旦执行了nanowrimoing对象，则再作nanowrimoing.notify调用将不会有任何反应，这就像任何额外的resolve调用及reject调用也会被直接无视一样。</p><p>Promise对象接受3种回调形式：done、fail和progress。执行Promise对象时，运行的是done回调；拒绝Promise对象时，运行的是fail回调；对处于挂起状态的Deferred对象调用notify时，运行的是progress回调。</p><h2 id="Promise-对象的合并"><a href="#Promise-对象的合并" class="headerlink" title="Promise 对象的合并"></a>Promise 对象的合并</h2><p>Promise对象的逻辑合并技术有一个最常见的用例：判定一组异步任务何时完成。假设我们正在播放一段演示视频，同时又在加载服务器上的一个游戏。我们希望这两件事一旦结束（对次序没有要求），就马上启动游戏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gameReadying = $.when(tutorialPromise, gameLoadedPromise);</span><br><span class="line">gameReadying.done(startGame);</span><br></pre></td></tr></table></figure><p>when相当于Promise执行情况的逻辑与运算符（AND）。<br>一旦给定的所有Promise均已执行，就立即执行when方法产生的Promise对象；或者，一旦给定的任意一个Promise被拒绝，就立即拒绝when产生的Promise。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.when($.post(<span class="string">'/1'</span>, data1), $.post(<span class="string">'/2'</span>, data2)).then(onPosted, onFailure);</span><br></pre></td></tr></table></figure><p>调用成功时，when可以访问下辖的各个成员Promise对象的回调参数，不过这么做很复杂。这些回调参数会当作参数列表进行传递，传递的次序和成员Promise对象传递给when方法时一样。如果某个成员Promise对象提供多个回调参数，则这些参数会先转换成数组<br>虽然有可能，但如果不是绝对必要，我们不应该自行解析when回调的参数，<br>相反应该直接向那些传递至when方法的成员Promise对象附加回调来收集相应的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverData = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> getting1 = $.<span class="keyword">get</span>('/1').done(function (result) &#123;</span><br><span class="line">    serverData[<span class="string">'1'</span>] = result;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> getting2 = $.<span class="keyword">get</span>('/2').done(function (result) &#123;</span><br><span class="line">    serverData[<span class="string">'2'</span>] = result;</span><br><span class="line">&#125;);</span><br><span class="line">$.when(getting1, getting2).done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 获得的信息现在都已位于serverData……</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="函数的promise用法"><a href="#函数的promise用法" class="headerlink" title="函数的promise用法"></a>函数的promise用法</h3><p>$.when及其他能取用Promise对象的jQuery方法均支持传入非Promise对象作为参数。<br>这些非Promise参数会被当成因相应参数位置已赋值而执行的Promise对象来处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.when(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure><p>会生成一个因赋值’foo’而立即执行的Promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = $.Deferred().resolve(<span class="string">'manchu'</span>);</span><br><span class="line">$.when(<span class="string">'foo'</span>, promise)</span><br></pre></td></tr></table></figure><p>会生成一个因赋值’foo’和’manchu’而立即执行的Promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = $.Deferred().resolve(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">$.when(<span class="string">'test'</span>, promise)</span><br></pre></td></tr></table></figure><p>会生成一个因赋值’test’和数组[1,2,3]而立即执行的Promise对象。（请记住，Deferred对象传递多个参数给resolve方法时，$.when会把这些参数转换成一个数组。）</p><p>$.when如何知道参数是不是Promise对象呢？答案是：jQuery负责检查$.when的各个参数是否带有promise方法，如果有就使用该方法返回的值。Promise对象的promise方法会直接返回自身。</p><p>jQuery对象也可以有promise方法，这意味着$.when方法强行将那些带promise方法的jQuery对象转换成了jQuery动画版Promise对象。因此，如果想生成一个在抓取某些数据且已完成#loading动画之后执行的Promise对象，只需写下下面这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetching = $.<span class="keyword">get</span>('/myData');</span><br><span class="line">$.when(fetching, $('#loading'));</span><br></pre></td></tr></table></figure><p>只是请记住，必须要在动画开始之后再执行$.when生成的那个Promise对象。<br>如果#loading的动画队列为空，则立即执行相应的Promise对象。</p><h2 id="管道连接未来"><a href="#管道连接未来" class="headerlink" title="管道连接未来"></a>管道连接未来</h2><p>在JavaScript中常常无法便捷地执行一系列异步任务，一个主要原因是无法在第一个任务结束之前就向第二个任务附加处理器。举个例子，假设我们要从一个URL抓取数据（GET），接着又将这些数据发送给另一个URL（POST）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getPromise = $.<span class="keyword">get</span>('/query');</span><br><span class="line">getPromise.done(function (data) &#123;</span><br><span class="line">    <span class="keyword">var</span> postPromise = $.post(<span class="string">'/search'</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看到这里的问题了吗？在GET操作成功之前我们无法对postPromise对象绑定回调，因为这时postPromise对象还不存在！除非我们已经得到因$.get调用而异步抓取的数据，否则甚至无法进行那个负责生成postPromise对象的$.post调用！</p><p>这正是jQuery 1.6为Promise对象新增pipe（管道）方法的原因。pipe好像在说：“请针对这个Promise对象给我一个回调，我会归还一个Promise对象以表示回调运行的结果。”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getPromise = $.<span class="keyword">get</span>('/query');</span><br><span class="line">var postPromise = getPromise.pipe(function(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> $.post(<span class="string">'/search'</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来就像黑魔法，对吧？下面是详情大揭秘：pipe最多能接受3个参数，它们对应着Promise对象的3种回调类型：done、fail和progress。<br>也就是说，我们在上述例子中只提供了执行getPromise时应运行的那个回调。当这个回调返回的Promise对象已经执行/拒绝时，pipe方法返回的那个新Promise对象也就可以执行/拒绝。</p><p>我们也可以通过修改pipe回调参数来“滤清”Promise对象。如果pipe方法的回调返回值不是Promise/Deferred对象，它就会变成回调参数。举例来说，假设有个Promise对象发出的进度通知表示成0与1之间的某个数，则可以使用pipe方法生成一个完全相同的Promise对象，但它发出的进度通知却转变成可读性更高的字符串。</p><ul><li>如果pipe回调返回的是Promise对象，则pipe生成的那个Promise对象会模仿这个Promise对象。</li><li>如果pipe回调返回的是非Promise对象（值或空白），则pipe生成的那个Promise对象会立即因该赋值而执行、拒绝或得到通知，具体取决于调用pipe的那个初始Promise对象刚刚发生了什么。</li></ul><p>pipe判定参数是否为Promise对象的方法和$.when完全一样：如果pipe的参数带有promise方法，则该方法的返回值会被当作Promise对象以代表调用pipe的那个初始Promise对象。再重申一次，promise. promise() === promise。</p><h3 id="管道级联技术"><a href="#管道级联技术" class="headerlink" title="管道级联技术"></a>管道级联技术</h3><p>pipe方法并不要求提供所有的可能回调。事实上，我们通常只想写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pipedPromise = originalPromise.pipe(successCallback);</span><br><span class="line"><span class="keyword">var</span> pipedPromise = originalPromise.pipe(<span class="literal">null</span>, failCallback);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getPromise = $.<span class="keyword">get</span>('/query');</span><br><span class="line">getPromise.done(function (data) &#123;</span><br><span class="line">    <span class="keyword">var</span> postPromise = $.post(<span class="string">'/search'</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> step1 = $.post(<span class="string">'/step1'</span>, data1);</span><br><span class="line"><span class="keyword">var</span> step2 = step1.pipe(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $.post(<span class="string">'/step2'</span>, data2);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> lastStep = step2.pipe(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $.post(<span class="string">'/step3'</span>, data3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的lastStep对象当且仅当所有这3个Ajax调用都成功完成时才执行，其中任意一个Ajax调用未能成功完成，lastStep均被拒绝。如果只在乎整体进程，则可以省略掉前面的变量声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> posting = $.post(<span class="string">'/step1'</span>, data1).pipe(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $.post(<span class="string">'/step2'</span>, data2).pipe(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $.post(<span class="string">'/step3'</span>, data3);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，这会重现金字塔厄运。大家应该了解这种书写风格，不过请尽量逐一声明pipe生成的那些Promise对象。也许并不需要这些变量名称，但它们能让代码更加自文档化<br>接下来简单介绍一下其主要替代方案：CommonJS的Promises/A规范及其旗舰版实现Q.js。</p><h3 id="jQuery与Promises-A的对比"><a href="#jQuery与Promises-A的对比" class="headerlink" title="jQuery与Promises/A的对比"></a>jQuery与Promises/A的对比</h3><p>jQuery的Promise与CommonJS的Promises/A几乎完全一样。<br>Q.js库是最流行的Promises/A实现，其提供的方法甚至能与jQuery的Promise和谐共存。这两者的区别只是形式上的，即用相同的词语表示不同的含义。<br>在jQuery 1.8问世之前，jQuery的then方法只是一种可以同时调用done、fail和progress这3种回调的速写法，<br>而Promises/A的then在行为上更像是jQuery的pipe。jQuery 1.8订正了这个问题，使得then成为pipe的同义词。不过，由于向后兼容的问题，jQuery的Promise再如何对Promises/A示好也不太会招人待见。<br>当然还有其他一些细微的差别。例如，在Promises/A规范中，由then方法生成的Promise对象是已执行还是已拒绝，取决于由then方法调用的那个回调是返回值还是抛出错误。（在jQuery的Promise对象的回调中抛出错误是个糟糕的主意，因为错误不会被捕获。）</p><p>基于上述原因，应该尽量避免在同一个项目中与多个Promise实现“打情骂俏”。如果因jQuery方法而得到Promise对象，请使用jQuery的Promise。如果因使用其他库而得到CommonJS Promise对象，则请遵守Promises/A规范。而Q.js可以轻松“消化”jQuery的Promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qPromise = Q.when(jqPromise);</span><br></pre></td></tr></table></figure><h3 id="用Promise对象代替回调函数"><a href="#用Promise对象代替回调函数" class="headerlink" title="用Promise对象代替回调函数"></a>用Promise对象代替回调函数</h3><p>理想情况下，开始执行异步任务的任何函数都应该返回Promise对象。遗憾的是，大多数JavaScript API（包括所有浏览器及Node.js均使用的那些原生函数）都基于回调函数，而不是基于Promise对象。在本节中，我们将看到如何在基于回调函数的API中使用Promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timing = <span class="keyword">new</span> $.Deferred();</span><br><span class="line">setTimeout(timing.resolve, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileReading = <span class="keyword">new</span> $.Deferred();</span><br><span class="line">fs.readFile(filename, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        fileReading.reject(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ileReading.resolve(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总这么写很麻烦，所以何不写一个工具函数以根据任何给定Deferred对象来生成Node风格的回调呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deferredCallback = <span class="function"><span class="keyword">function</span> (<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            deferred.reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deferred.resolve(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个工具函数，前面那个例子就可以写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileReading = <span class="keyword">new</span> $.Deferred();</span><br><span class="line">fs.readFile(filename, <span class="string">'utf8'</span>, deferredCallback(fileReading));</span><br></pre></td></tr></table></figure><p>Q.js的Deferred对象为此提供了一个现成的node方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileReading = Q.defer();</span><br><span class="line">fs.readFile(filename, <span class="string">'utf8'</span>, fileReading.node());</span><br></pre></td></tr></table></figure><p>随着Promise越来越流行，会有越来越多的JavaScript库循着jQuery的脚步，要求其异步函数必须返回Promise对象。到那时，只需要几行代码就能将想用的任何异步函数转变成Promise对象的生成函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Promise-对象和-Deferred-对象&quot;&gt;&lt;a href=&quot;#Promise-对象和-Deferred-对象&quot; class=&quot;headerlink&quot; title=&quot;Promise 对象和 Deferred 对象&quot;&gt;&lt;/a&gt;Promise 对象和 Deferred 对象&lt;/h1&gt;&lt;p&gt;Promise对象的最大优势仍然在于，它可以轻松从现有Promise对象派生出新的Promise对象。我们可以要求代表着并行任务的两个Promise对象合并成一个Promise对象，由后者负责通知前面那些任务都已完成。也可以要求代表着任务系列中首任务的Promise对象派生出一个能代表任务系列中末任务的Promise对象，这样后者就能知道这一系列任务是否均已完成。待会儿我们就会看到，Promise对象天生就适合用来进行这些操作。&lt;/p&gt;
&lt;h2 id=&quot;Promise极简史&quot;&gt;&lt;a href=&quot;#Promise极简史&quot; class=&quot;headerlink&quot; title=&quot;Promise极简史&quot;&gt;&lt;/a&gt;Promise极简史&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2007 Dojo框架刚从Twisted框架汲取灵感，新增了一个叫做dojo.Deferred的对象。&lt;/li&gt;
&lt;li&gt;2009 Kris Zyp有感于dojo.Deferred的影响力提出了CommonJS之Promises/A规范&lt;/li&gt;
&lt;li&gt;同年，Node.js首次亮相。Node早期的几个版本在其非阻塞式API中用到了Promise。&lt;/li&gt;
&lt;li&gt;2010 Ryan Dahl决定切换至当时为人所熟知的callback(err, result…)格式，因为Promise是一种属于“用户之境”的甚高层构造。&lt;/li&gt;
&lt;li&gt;2011 jQuery 1.5在2011年1月携$.ajax重量级重写之势，用其Promise实现震惊了无数初次接触Promise对象的开发者。不过，其他的开发者则忧心忡忡，因为jQuery 1.5对Promises/A规范的无视导致了微妙的API差异。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript 异步编程读书笔记" scheme="http://tonnyone.github.io/categories/javascript-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript 异步编程-2.分布式事件</title>
    <link href="http://tonnyone.github.io/2017/12/05/javascript/fen-bu-shi-shi-jian/"/>
    <id>http://tonnyone.github.io/2017/12/05/javascript/fen-bu-shi-shi-jian/</id>
    <published>2017-12-04T16:00:00.000Z</published>
    <updated>2021-01-11T21:33:44.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事件"><a href="#分布式事件" class="headerlink" title="分布式事件"></a>分布式事件</h1><p>在本章中，你将会学到如何使用PubSub（Publish/Sub-scribe，意为“发布/订阅”）模式来分发事件。<br>沿着这个思路，我们会看到PubSub模式的一些具体表现：Node的EventEmitter对象、Backbone的事件化模型和jQuery的自定义事件。<br>在这些工具的帮助下，我们能解嵌套那些嵌套式回调，减少重复冗余，最终编写出易于理解的事件驱动型代码。</p><a id="more"></a><h2 id="PubSub-模式"><a href="#PubSub-模式" class="headerlink" title="PubSub 模式"></a>PubSub 模式</h2><h3 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h3><p>从JavaScript诞生之日起，浏览器就允许向DOM元素附加事件处理器,形如 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一个事件添加多个处理器必须这么处理</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">link.onclick = function() &#123;</span><br><span class="line">  clickHandler1.apply(this, arguments); </span><br><span class="line">  clickHandler2.apply(this, arguments);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>nodejs 包含了一个一般性的PubSub实体,EventEmitter。nodejs 中几乎所有的 I/O源都式EventEmitter对象。 文件流，http服务器，甚至应用进程本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'room'</span>, <span class="string">'moon'</span>, <span class="string">'cow jumping over the moon'</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Goodnight, '</span> + name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'evacuate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;  <span class="built_in">console</span>.log(message);&#125;);</span><br><span class="line">emitter.emit(<span class="string">'evacuate'</span>, <span class="string">'Woman and children first!'</span>);</span><br></pre></td></tr></table></figure><p>EventEmitter对象的所有方法都是公有的，但一般约定只能从EventEmitter对象的“内部”触发事件。也就是说，如果有一个对象继承了EventEmitter原型并使用了this.emit方法来广播事件，则不应该从这个对象之外的其他地方再调用其emit方法。</p><h3 id="构建自己的PUB-SUB"><a href="#构建自己的PUB-SUB" class="headerlink" title="构建自己的PUB/SUB"></a>构建自己的PUB/SUB</h3><p>如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PubSub = &#123;</span><br><span class="line">    handlers: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">PubSub.on = <span class="function"><span class="keyword">function</span> (<span class="params">eventType, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(eventType <span class="keyword">in</span> <span class="keyword">this</span>.handlers)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handlers[eventType] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.handlers[eventType].push(handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">PubSub.emit = <span class="function"><span class="keyword">function</span> (<span class="params">eventType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> handlerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.handlers[eventType].length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handlers[eventType][i].apply(<span class="keyword">this</span>, handlerArgs);</span><br><span class="line">    &#125;  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PubSub模式的实现这么简单，需要添加监听事件的时候,只要将监听器推入数组的末尾即可.<br>触发事件的时候再循环遍历所有的事件处理器.<br>这里我们相当于实现了PUB/SUB的核心部分，移除事件和附加一次性事件处理器功能暂时没有实现.</p><p>JQUERY 库里面到处都有几个不同的Pub/Sub实现，于是决定再Jquery1.7将他们抽象为$.Callbacks<br>还有的Pub/Sub负责解析字符串时实现一些特殊的功能，<br>如: </p><ul><li>jquery “click.tbb” “hover.tbb” 通过unbind.(“tbb”) 就可以同时解绑两个事件</li><li>BackBone的All事件</li><li>jquery 和 BackBone 支持用空格隔开多个事件来同时绑定和触发多种事件类型</li></ul><h3 id="同步性"><a href="#同步性" class="headerlink" title="同步性"></a>同步性</h3><p>尽管Pub/Sub 模式是一项处理异步事件的重要技术,但它内部和异步没有一点关系.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'input[type=submit]'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;).trigger(<span class="string">'click'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bar'</span>);</span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>这证明了click事件的处理器因trigger方法而立即被激活。事实上，只要触发了jQuery事件，就会不被中断地按顺序执行其所有事件处理器。</p><p>如果事件按顺序触发了过多的处理器，就会有阻塞线程且导致浏览器不响应的风险。更糟糕的是，如果事件处理器本身触发了事件，还很容易造成无限循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'input[type=submit]'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; $(<span class="keyword">this</span>).trigger(<span class="string">'click'</span>);  <span class="comment">//堆栈上溢！&#125;);</span></span><br></pre></td></tr></table></figure><p>回想本章开头提到的文字处理程序的例子。用户按键时，需要发生很多事情，其中某些事还需要复杂的计算。全部做完这些事之后再返回事件队列，只会制造出响应迟钝的应用。</p><p>解决办法: 就是对那些无需即刻发生的事情维持一个队列，并使用一个计时函数定时运行此队列中的下一项任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tasks = []; </span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> nextTask; </span><br><span class="line">    <span class="keyword">if</span> (nextTask = tasks.shift()) &#123;</span><br><span class="line">         nextTask();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="事件化模型"><a href="#事件化模型" class="headerlink" title="事件化模型"></a>事件化模型</h2><p>只要对象带有PubSub接口，就可以称之为<strong>事件化对象</strong>。特殊情况出现在用于存储数据的对象因内容变化而发布事件时，这里用于存储数据的对象又称作模型。模型就是MVC（Model-View-Controller，模型-视图-控制器）中的那个M。MVC三层架构设计模式在最近几年里已经成为JavaScript编程中最热点的主题之一。MVC的核心理念是应用程序应该以数据为中心，所以模型发生的事件会影响到DOM（即MVC中的视图）和服务器（通过MVC中的控制器而产生影响）。</p><p>老式的JavaScript依靠输入事件的处理器直接改变DOM。新式的JavaScript先改变模型，接着由模型触发事件而导致DOM的更新。在几乎所有的应用程序中，这种关注层面的分离都会带来更优雅、更直观的代码。</p><h3 id="模型事件的传播"><a href="#模型事件的传播" class="headerlink" title="模型事件的传播"></a>模型事件的传播</h3><p>正如我们知道的，JavaScript确实没有一种每当对象变化时就触发事件的机制。因此请记住，事件化模型要想工作的话，必须要使用一些像Backbone.js之set/get这样的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">style.set(&#123;<span class="attr">font</span>: <span class="string">'Palatino'</span>&#125;);     <span class="comment">// 触发器警报！</span></span><br><span class="line">style.get(<span class="string">'font'</span>);                 <span class="comment">// 结果为"Palatino"</span></span><br><span class="line">style.font = <span class="string">'Comic Sans'</span>;         <span class="comment">// 未触发任何事件</span></span><br><span class="line">style.font; <span class="comment">// 结果为"Comic Sans"style.get('font');</span></span><br><span class="line"><span class="comment">// 结果仍为"Palatino"</span></span><br></pre></td></tr></table></figure><p>将来也许无需如此，前提是名为Object.observe的EC-MAScript提案已经获得广泛接纳。</p><h3 id="事件的循环和嵌套式变化"><a href="#事件的循环和嵌套式变化" class="headerlink" title="事件的循环和嵌套式变化"></a>事件的循环和嵌套式变化</h3><p>从一个对象向另一个对象传播事件的过程提出了一些需要关注的问题。<br>如果每次有个对象上的事件引发了一系列事件并最终对这个对象本身触发了相同的事件，则结果就是事件循环。<br>如果这种事件循环还是同步的，那就造成了堆栈上溢，</p><p>然而在很多时候，变化事件的循环恰恰是我们想要的。最常见的情况就是双向绑定——两个模型的取值会彼此关联。<br>假设我们想保证x始终等于2 * y。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Backbone.Model(&#123;</span><br><span class="line">    value: <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Backbone.Model(&#123;</span><br><span class="line">    value: <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">x.on(<span class="string">'change:value'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">x, xVal</span>) </span>&#123;</span><br><span class="line">    y.set(&#123;</span><br><span class="line">        value: xVal / <span class="number">2</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">y.on(<span class="string">'change:value'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">y, yVal</span>) </span>&#123;</span><br><span class="line">    x.set(&#123;</span><br><span class="line">        value: <span class="number">2</span> * yVal</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你可能觉得当x或y的取值变化时，这段代码会导致无限循环。但实际上它相当安全，这要感谢Backbone中的两道保险。</p><ul><li>当新值等于旧值时，set方法不会导致触发change事件。</li><li>模型正处于自身的change事件期间时，不会再触发change事件。</li></ul><p>很明显，在Backbone中维持双向数据绑定是一个挑战。而另一个重要的MVC框架，即Ember.js，采用了一种完全不同的方式：双向绑定必须作显式声明。一个值发生变化时，另一个值会通过延时事件作异步更新。于是，在触发这个异步更新事件之前，应用程序的数据将一直处于不一致的状态。(此处后来者<strong>angularjs，vue都借鉴与此</strong>)</p><p>多个事件化模型之间的数据绑定问题不存在简单的解决方案。<br>在Backbone中，有一种审慎绕过这个问题的途径就是silent标志。<br>如果在set方法中添加了{silent:true}选项，则不会触发change事件。<br>因此，如果多个彼此纠结的模型需要同时进行更新，一个很好的解决方法就是悄无声息地设置它们的值。<br>然后，当这些模型的状态已经一致时，才调用它们的change方法以触发对应的事件。</p><p>事件化模型为我们带来了一种将应用状态变化转换为事件的直观方式。Backbone及其他MVC框架做的每件事都跟这些模型有关，这些模型的状态变化会触发DOM和服务器进行更新。要想掌控客户端JavaScript应用程序与日俱增的复杂度，运用事件化模型存储互斥数据是伟大长征的第一步。(作者此处非常有远见)</p><h3 id="Jquery-的自定义事件"><a href="#Jquery-的自定义事件" class="headerlink" title="Jquery 的自定义事件"></a>Jquery 的自定义事件</h3><p>自定义事件是jQuery被低估的特性之一，它简化了强大分布式事件系统向任何Web应用程序的移植，而且无需额外的库。在jQuery中，可以使用trigger方法基于任意DOM元素触发任何想要的事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#tabby, #socks'</span>).on(<span class="string">'meow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.id + <span class="string">' meowed'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'#tabby'</span>).trigger(<span class="string">'meow'</span>); <span class="comment">// "tabby meowed"$('#socks').trigger('meow'); // "socks meowed"</span></span><br></pre></td></tr></table></figure><p>冒泡技术。只要某个DOM元素触发了某个事件（譬如’click’事件），其父元素就会接着触发这个事件，接着是父元素的父元素，以此类推，一直上溯到根元素（即document），除非在这条冒泡之路的某个地方调用了事件的stopPropagation方法。</p><p>你是否也知道jQuery自定义事件的冒泡技术?<br>举个例子，假设有个名称为“soda”的span元素嵌套在名称为“bottle”的div元素中，<br>代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#soda, #bottle'</span>).on(<span class="string">'fizz'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.id + <span class="string">' emitted fizz'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'#soda'</span>).trigger(<span class="string">'fizz'</span>);</span><br><span class="line"><span class="comment">//soda emitted fizz</span></span><br><span class="line"><span class="comment">//bottle emitted fizz</span></span><br></pre></td></tr></table></figure><p>这种冒泡方式并非始终受人欢迎，幸运的是，jQuery同样提供了非冒泡式的triggerHandler方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式事件&quot;&gt;&lt;a href=&quot;#分布式事件&quot; class=&quot;headerlink&quot; title=&quot;分布式事件&quot;&gt;&lt;/a&gt;分布式事件&lt;/h1&gt;&lt;p&gt;在本章中，你将会学到如何使用PubSub（Publish/Sub-scribe，意为“发布/订阅”）模式来分发事件。&lt;br&gt;沿着这个思路，我们会看到PubSub模式的一些具体表现：Node的EventEmitter对象、Backbone的事件化模型和jQuery的自定义事件。&lt;br&gt;在这些工具的帮助下，我们能解嵌套那些嵌套式回调，减少重复冗余，最终编写出易于理解的事件驱动型代码。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript 异步编程读书笔记" scheme="http://tonnyone.github.io/categories/javascript-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript 异步编程-1.深入理解javascript事件</title>
    <link href="http://tonnyone.github.io/2017/12/01/javascript/shen-ru-li-jie-javascript-shi-jian/"/>
    <id>http://tonnyone.github.io/2017/12/01/javascript/shen-ru-li-jie-javascript-shi-jian/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2021-01-11T21:33:44.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解javascript事件"><a href="#深入理解javascript事件" class="headerlink" title="深入理解javascript事件"></a>深入理解javascript事件</h1><h2 id="事件的调度"><a href="#事件的调度" class="headerlink" title="事件的调度"></a>事件的调度</h2><h3 id="最常见的一个例子"><a href="#最常见的一个例子" class="headerlink" title="最常见的一个例子"></a>最常见的一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line"> setTimeout(function()&#123;</span><br><span class="line">     console.log(i);</span><br><span class="line"> &#125;, 0);</span><br><span class="line">&#125;;</span><br><span class="line">// 4 4 4</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>循环结束后JavaScript的事件处理器才开始执行</p></blockquote><h3 id="关于setTimeout的理解"><a href="#关于setTimeout的理解" class="headerlink" title="关于setTimeout的理解"></a>关于setTimeout的理解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">setTimeout (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Time elapsed:'</span>, end - start,<span class="string">'ms'</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span> - start; <span class="number">1000</span>) &#123;&#125;;</span><br><span class="line"><span class="comment">// Time elapsed:</span></span><br><span class="line"><span class="comment">// 1010 ms</span></span><br><span class="line"><span class="comment">// Time elapsed:</span></span><br><span class="line"><span class="comment">// 1015ms</span></span><br></pre></td></tr></table></figure><ol><li><p>按照多线程的思维定势，计500毫秒后计时函数就会运行。不过这要求中断欲持续整整一秒钟的循环。每次的结果都会稍有不同,但是总是大于1000ms.因为setTimeout回调在while循环结束运行之前不可能被触发.</p></li><li><p>调用setTimeout的时候，会有一个延时事件排入队列。然后setTimeout调用之后的那行代码运行，接着是再下一行代码，直到再也没有任何代码。这时JavaScript虚拟机才会问：“队列里都有谁啊？”</p></li><li><p>事件的易调度性是JavaScript语言最大的特色之一。像set-Timeout这样的异步函数只是简单地做延迟执行，而不是孵化新的线程。JavaScript代码永远不会被中断，这是因为代码在运行期间只需要排队事件即可，而这些事件在代码运行结束之前不会被触发。</p></li></ol><h2 id="异步函数的类型"><a href="#异步函数的类型" class="headerlink" title="异步函数的类型"></a>异步函数的类型</h2><blockquote><p>JavaScript环境提供的异步函数通常可以分为两大类：I/O函数和计时函数。<br>如果想在应用中定义复杂的异步行为，就要使用这两类异步函数作为基本的构造块。</p></blockquote><h3 id="异步的IO函数"><a href="#异步的IO函数" class="headerlink" title="异步的IO函数"></a>异步的IO函数</h3><ol><li><p>创造Node.js，并不是为了人们能在服务器上运行JavaScript，仅仅是因为Ryan Dahl想要一个建立在某高级语言之上的事件驱动型服务器框架。JavaScript碰巧就是适合干这个的语言。为什么？因为JavaScript语言可以完美地实现非阻塞式I/O。</p></li><li><p>在浏览器端，Ajax方法有一个可设置为false的async选项（但永远、永远别这么做），这会挂起整个浏览器窗格直到收到应答为止。在Node.js中，同步的API方法在名称上会有明确的标示，譬如fs.readFileSync。编写短小的脚本时，这些同步方法会很方便。但是，如果所编写的应用需要处理并行的多个请求或多项操作，则应该避免使用它们。</p></li><li><p>有些I/O函数既有同步效应，也有异步效应。举例来说，在现代浏览器中操纵DOM对象时，从脚本角度看，更改是即时生效的，但从视效角度看，在返回事件队列之前不会渲染这些DOM对象更改。<a href="http://jsfiddle.net/TrevorBurnham/SNBYV/" target="_blank" rel="noopener">jsfiddle示例</a>。</p></li></ol><p>console.log是异步的吗 ?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(obj);</span><br><span class="line">obj.foo = &apos;bar&apos;;</span><br></pre></td></tr></table></figure><p>怎么会这样 ?</p><ol><li>WebKit的console.log并没有立即拍摄对象快照，相反，它只存储了一个指向对象的引用，然后在代码返回事件队列时才去拍摄快照。</li><li>Node的console.log是另一回事，它是严格同步的，因此同样的代码输出的却为{}。</li></ol><h3 id="异步的计时函数"><a href="#异步的计时函数" class="headerlink" title="异步的计时函数"></a>异步的计时函数</h3><h4 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fireCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>  (<span class="keyword">new</span> <span class="built_in">Date</span>-start &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">           clearInterval(timer);</span><br><span class="line">           <span class="built_in">console</span>.log(fireCount);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fireCount++;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="number">0</span>);</span><br><span class="line"><span class="comment">// 246</span></span><br><span class="line"><span class="comment">// 251</span></span><br></pre></td></tr></table></figure><ul><li><p>大约为200次/秒。这是Chrome、Safari和Firefox等浏览器的平均值。</p></li><li><p>在Node环境下，此事件的触发频率大约能达到600次/秒。（若使用setTimeout来调度事件，重复这些实验也会得到类似的结果。）作为对比，</p></li><li><p>如果将setInterval替换成简单的while循环，则在Chrome中此事件的触发频率将达到400万次/秒，而在Node中会达到500万次/秒！ </p></li><li><p>这是怎么回事？最后我们发现，setTimeout和setInterval就是想设计成慢吞吞的！事实上，HTML规范（这是所有主要浏览器都遵守的规范）推行的延时/时隔的最小值就是4毫秒.</p></li><li><p>在Node中，<strong>process.nextTick</strong> 允许将事件调度成尽可能快地触发。对于笔者的系统，process.nextTick事件的触发频率可以超过10万次/秒。</p></li><li><p>一些现代浏览器（含IE9+）带有一个requestAnimation-Frame函数。此函数有两个目标：一方面，它允许以60+帧/秒的速度运行JavaScript动画；另一方面，它又避免后台选项卡运行这些动画，从而节约CPU周期。在最新版的Chrome浏览器中，甚至能实现亚毫秒级的精度。</p></li><li><p>setTimeout和setInterval就是些不精确的计时工具。在Node中，如果只是想产生一个短时延迟，请使用pro-cess.nextTick。在浏览器端，请尝试使用垫片技术（shim）：在支持requestAnimationFrame的浏览器中，推荐使用reques-tAnimationFrame；在不支持requestAnimationFrame的浏览器中，则退而使用setTimeout。</p></li></ul><h2 id="异步函数的编写"><a href="#异步函数的编写" class="headerlink" title="异步函数的编写"></a>异步函数的编写</h2><blockquote><p>JavaScript中的每个异步函数都构建在其他某个或某些异步函数之上。凡是异步函数，从上到下（一直到原生代码）都是异步的！</p><p>遗憾的是，要想确认某个函数异步与否，唯一的方法就是审查其源代码。有些同步函数却拥有看起来像是异步的API，这或者是因为它们将来可能会变成异步的，又或者是因为回调这种形式能方便地返回多个参数。</p></blockquote><h3 id="间或异步函数"><a href="#间或异步函数" class="headerlink" title="间或异步函数"></a>间或异步函数</h3><blockquote><p>有些函数某些时候是异步的，但其他时候却不然。举个例子，jQuery的同名函数（通常记作$）可用于延迟函数直至DOM已经结束加载。但是，若DOM早已结束了加载，则不存在任何延迟，$的回调将会立即触发。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(function() &#123;  </span><br><span class="line">    utils.log('Ready');</span><br><span class="line">&#125;);</span><br><span class="line">//utils.js</span><br><span class="line">window.utils = &#123;  </span><br><span class="line">    log: function() &#123; </span><br><span class="line">       if (window.console) </span><br><span class="line">       console.log.apply(console, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> ＝"<span class="attr">application.js</span>"&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> ＝"<span class="attr">util.js</span>"&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码运行得很好，但前提是浏览器并未从缓存中加载页面（这会导致DOM早在脚本运行之前就已加载就绪）。如果出现这种情况，传递给$的回调就会在设置utils.log之前运行，从而导致一个错误。</p><h3 id="缓存型异步函数"><a href="#缓存型异步函数" class="headerlink" title="缓存型异步函数"></a>缓存型异步函数</h3><h3 id="异步递归和回调存储"><a href="#异步递归和回调存储" class="headerlink" title="异步递归和回调存储"></a>异步递归和回调存储</h3><blockquote><p>请避免异步递归。仅当所采用的库提供了异步功能但没有提供任何形式的回调机制时，异步递归才有必要。如果真的遇到这种情况，要做的第一件事应该是为该库写一个补丁。或者，干脆找一个更好的库。</p></blockquote><h3 id="返回值与回调的混搭"><a href="#返回值与回调的混搭" class="headerlink" title="返回值与回调的混搭"></a>返回值与回调的混搭</h3><h2 id="异步错误处理"><a href="#异步错误处理" class="headerlink" title="异步错误处理"></a>异步错误处理</h2><p>如果从异步回调中抛出错误，会发生什么事？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">     setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Something terrible has happened!'</span>);</span><br><span class="line">        &#125;,<span class="number">0</span>); </span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//Error: Something terrible has happened!</span></span><br><span class="line"><span class="comment">//    at C (script 1:94)</span></span><br></pre></td></tr></table></figure><p>上述应用的结果是一条极其简短的堆栈轨迹。，A和B发生了什么事？为什么它们没有出现在堆栈轨迹中？这是因为运行C的时候，A和B并不在内存堆栈里。这3个函数都是从事件队列直接运行的。基于同样的理由，利用try/catch语句块并不能捕获从异步回调中抛出的错误。</p><p>总的来说，取用异步回调的函数即使包装上try/catch语句块，也只是无用之举。（特例是，该异步函数确实是在同步地做某些事且容易出错。例如，Node的fs.watch(file,callback)就是这样一个函数，它在目标文件不存在时会抛出一个错误。）正因为此，Node.js中的回调几乎总是接受一个错误作为其首个参数，这样就允许回调自己来决定如何处理这个错误。举个例子，下面这个Node应用尝试异步地读取一个文件，还负责记录下任何错误（如“文件不存在”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'fhgwgdz.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString(<span class="string">'utf8'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/data',</span><br><span class="line"> &#123; success: successHandler, </span><br><span class="line"> failure: failureHandler&#125;</span><br><span class="line">);<span class="string">`</span></span><br></pre></td></tr></table></figure><p>不管API形态像什么，始终要记住的是，<strong>只能在回调内部处理源于回调的异步错误</strong></p><h3 id="未捕获的异常处理"><a href="#未捕获的异常处理" class="headerlink" title="未捕获的异常处理"></a>未捕获的异常处理</h3><h4 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h4><p>现代浏览器会在开发人员控制台显示那些未捕获的异常，接着返回事件队列。要想修改这种行为，可以给window.onerror附加一个处理器。如果windows.onerror处理器返回true，则能阻止浏览器的默认错误处理行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//彻底忽略所有错误&#125;;</span></span><br></pre></td></tr></table></figure><p>在成品应用中，会考虑某种JavaScript错误处理服务，譬如:<a href="https://errorception.com/" target="_blank" rel="noopener">Errorception</a>。Errorception提供了一个现成的windows.on-error处理器，它向应用服务器报告所有未捕获的异常，接着应用服务器发送消息通知我们。</p><h4 id="NodeJs-环境"><a href="#NodeJs-环境" class="headerlink" title="NodeJs 环境"></a>NodeJs 环境</h4><p>在Node环境中，window.onerror的类似物就是process对象的uncaughtException事件。正常情况下，Node应用会因未捕获的异常而立即退出。但只要至少还有一个uncaughtExcep-tion事件处理器，Node应用就会直接返回事件队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;  <span class="built_in">console</span>.error(err);  &#125;);<span class="comment">//避免了进程停止</span></span><br></pre></td></tr></table></figure><p>但是，自Node 0.8.4起，uncaughtException事件就被废弃了。据其文档所言，</p><blockquote><p>对异常处理而言，uncaughtException是一种非常粗暴的机制，它在将来可能会被放弃……请勿使用uncaughtException，而应使用Domain对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDomain = <span class="built_in">require</span>(<span class="string">'domain'</span>).create();</span><br><span class="line">myDomain.run(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Listen to me!'</span>)</span><br><span class="line">    &#125;, <span class="number">50</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myDomain.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error ignored!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>源于延时事件的throw只是简单地触发了Domain对象的错误处理器。</p><h3 id="抛出还是不抛出"><a href="#抛出还是不抛出" class="headerlink" title="抛出还是不抛出"></a>抛出还是不抛出</h3><p>如果抛出那些自己知道肯定会被捕获的异常呢？这种做法同样凶险万分。2011年，Isaac Schlueter（npm的开发者，在任的Node开发负责人）就主张try/catch是一种“反模式”的方式。<br>Schlueter提倡完全将throw用作断言似的构造结构，作为一种挂起应用的方式——当应用在做完全没预料到的事时，即挂起应用。Node社区主要遵循这一建议，尽管这种情况可能会随着Domain对象的出现而改变。</p><h3 id="嵌套式回调的解嵌套"><a href="#嵌套式回调的解嵌套" class="headerlink" title="嵌套式回调的解嵌套"></a>嵌套式回调的解嵌套</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPassword</span>(<span class="params">username, passwordGuess, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> queryStr = <span class="string">'SELECT * FROM user WHERE username = ?'</span>;</span><br><span class="line">    db.query(queryStr, username, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        hash(passwordGuess, <span class="function"><span class="keyword">function</span> (<span class="params">passwordGuessHash</span>) </span>&#123;</span><br><span class="line">            callback(passwordGuessHash === result[<span class="string">'password_hash'</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有什么问题呢？目前为止，没有任何问题。它能用，而且简洁明了。但是，如果试图向其添加新特性，它就会变得毛里毛躁、险象环生，比如去处理那个数据库错误，而不是抛出错误（请参阅1.4.3节）、记录尝试访问数据库的次数、阻塞访问数据库，等等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPassword</span>(<span class="params">username, passwordGuess, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> passwordHash;</span><br><span class="line">    <span class="keyword">var</span> queryStr = <span class="string">'SELECT * FROM user WHERE username = ?'</span>;</span><br><span class="line">    db.query(qyeryStr, username, queryCallback);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">queryCallback</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        passwordHash = result[<span class="string">'password_hash'</span>];</span><br><span class="line">        hash(passwordGuess, hashCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hashCallback</span>(<span class="params">passwordGuessHash</span>) </span>&#123;</span><br><span class="line">        callback(passwordHash === passwordGuessHash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法更啰嗦一些，但读起来更清晰，也更容易扩展。由于这里赋予了异步结果（即passwordHash）更宽广的作用域，所以获得了更大的灵活性。<br>按照惯例，请避免两层以上的函数嵌套。关键是找到一种在激活异步调用之函数的外部存储异步结果的方式，这样回调本身就没有必要再嵌套了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入理解javascript事件&quot;&gt;&lt;a href=&quot;#深入理解javascript事件&quot; class=&quot;headerlink&quot; title=&quot;深入理解javascript事件&quot;&gt;&lt;/a&gt;深入理解javascript事件&lt;/h1&gt;&lt;h2 id=&quot;事件的调度&quot;&gt;&lt;a href=&quot;#事件的调度&quot; class=&quot;headerlink&quot; title=&quot;事件的调度&quot;&gt;&lt;/a&gt;事件的调度&lt;/h2&gt;&lt;h3 id=&quot;最常见的一个例子&quot;&gt;&lt;a href=&quot;#最常见的一个例子&quot; class=&quot;headerlink&quot; title=&quot;最常见的一个例子&quot;&gt;&lt;/a&gt;最常见的一个例子&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for (var i = 1; i &amp;lt;= 3; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; setTimeout(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     console.log(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 4 4 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript 异步编程读书笔记" scheme="http://tonnyone.github.io/categories/javascript-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
